Clase 11 Repaso de Git y más
En chatgpt 4.0 Windows

1. Ve al sitio oficial: https://git-scm.com/download/win
2. Se descargara automaticamente un instalador
3. Ejecuta el instalador y sigue las instrucciones del asistente.

· Puedes dejar la mayoría de las opciones por defecto.
· Se recomienda instalar también Git Bash, que se incluye.

Para verificar que Git se instaló:

bash 
 git version
git -- version

https://git-scm.com/download/win esta es para instalar Git para windows

ya lo tengo instalado que configuracion inicial necesito hacer

1. Configurar tu nombre y correo
Estos datos aparecerán en cada commit que hagas:

bash
git config -- global user.name "Tu Nombre"
git config -- global user.email "tucorreo@example.com"

Por ejemplo:

bash

git config -- global user.name "Juan Perez"
git config -- global user.email "juanperez@gmai

El flag -- global aplica la configuración a todo tu sistema. Si prefieres configurar solo para un repositorio específico, quítale -- global .

3. Configurar el editor de texto (opcional) no lo hicimos
Git usa un editor de texto por defecto (como Vim) para mensajes de commit. Puedes cambiarlo a otro, por
ejemplo, a Visual Studio Code:

bash
git config -- global core.editor "code -- wait"

4. Configurar el manejo de saltos de línea (solo si trabajas en Windows)no lo hicimos
Si estás en Windows, es buena idea decirle a Git cómo manejar los saltos de línea para evitar errores en
proyectos compartidos:

bash
git config -- global core.autocrlf true

5. (Opcional) Activar colores para una mejor visualizacion no lo hicimos
no lo hicimos
bash
git config -- global color.ui auto

git config --list sí lo hicimos
como clonar lo veremos después

-Como inicializo un repositorio?

1. Ve al directorio donde quieres iniciar el repositorio

Abre tu terminal y navega hasta la carpeta:

bash
cd ruta/de/tu/proyecto

Ejemplo:

bash
cd ~/Documentos/mi-proyecto

2. Inicializa el repositorio

Una vez dentro de la carpeta, ejecuta:

bash
git init

Esto crea un subdirectorio oculto llamado .git que contiene todos los archivos internos del repositorio.

3. Agrega archivos al repositorio local al staging area
Puedes agregar archivos especificos o todos los archivos del directorio:

bash
git add .

O agregar uno en particular.

bach
git add archivo.txt

4. Haz tu primer commit

bash
git commit -m "Tercer commit"

(Opcional) 5. Conecta tu repositorio local a uno remoto (como GitHub)
Si ya tienes un repositorio en GitHub, puedes vincularlo así:

bash
git remote add origin https://github.com/tu-usuario/nombre-repo.git
git remote add origin https://github.com/NENIA34/IAPythonPrincipiantes.git

Y luego subir tus archivos:
git push -u origin master
git push -u origin main
Si usas ramas modernas como main, reemplaza master por main.


--entonces yo creo en el escritorio la carpeta taller, la abro h escribo cmd en la ventana de archivos estando dentro de la carpeta y tildo ver elementos ocultos
 y hago git init para inicializar una base de datos de control de versiones.
PS C:\Users\servi> git init
Initialized empty Git repository in C:/Users/servi/.git/
PS C:\Users\servi>

En la carpeta Taller se creó una carpeta oculta .git

hooks 	carpeta de archivos
info		carpeta de archivos
objects	carpeta de archivos
refs		carpeta de archivos

config
description
HEAD

que son las bases de datos de versiones, lo que cargue y cree, git la mirará y la seguirá

C:\Users\servi\OneDrive\Desktop\Taller>git status
On branch master
No commits yet
nothing to commit (create/copy files and use "git add" to track)

Agrego un archivo a la carpeta Taller, no al .git, y hago

C:\Users\servi\OneDrive\Desktop\Taller>git status
On branch master
No commits yet
Untracked files:
  (use "git add <file>..." to include in what will be committed)

        nothing added to commit but untracked files present (use "git add" to track)
para que haga un seguimiento para todo lo que hay en esta carpeta

Entonces ahora creo mi archivo.txt en la carpeta taller
y le escribo hola a todos. yguardo

C:\Users\servi\OneDrive\Desktop\Taller>git status
On branch master

No commits yet

Untracked files:
  (use "git add <file>..." to include in what will be committed)
        mi archivo.txt

nothing added to commit but untracked files present (use "git add" to track)

Aquí mi archivo.txt está en rojo porque no hice git add y está en el working directory, no pasó al staging area, puedo poner git add "nombre del archivo y extensión" o bien si quiero hacer un seguimiento de todo lo que está en el working Directory hago git add .

C:\Users\servi\OneDrive\Desktop\Taller>git add .

C:\Users\servi\OneDrive\Desktop\Taller>

C:\Users\servi\OneDrive\Desktop\Taller>git status
On branch master

No commits yet

Changes to be committed:
  (use "git rm --cached <file>..." to unstage)
        new file:   mi archivo.txt


C:\Users\servi\OneDrive\Desktop\Taller>

ahora mi archivo.txt está en verde y no rojo como antes porque ahora sí se le está haciendo seguimiento, git ya lo marcó y le esstá haciendo seguimiento, el archivo esstá en el

					Staging Area

Esto significa que cualquier cambio que haga en los archivos serán detectados, en este caso es un solo archivo.

Ahora quiero pasar el archivo de la Staging Area al Local Repository, dentro de Git, esto se hace mediante git commit

C:\Users\servi\OneDrive\Desktop\Taller>git commit -m "Primer commit"
[master (root-commit) 8675e4e] Primer commit
 1 file changed, 1 insertion(+)
 create mode 100644 mi archivo.txt
C:\Users\servi\OneDrive\Desktop\Taller>

C:\Users\servi\OneDrive\Desktop\Taller>git status
On branch master
nothing to commit, working tree clean
C:\Users\servi\OneDrive\Desktop\Taller>

paso de working directory, a staging area y ya está el archivo en el Local Repository

Ahora abro el archivo y lo modifico ahora dice 
hola a todos
como estan 
esto es una prueba de git

para saber dónde está el archivo hago

C:\Users\servi\OneDrive\Desktop\Taller>git status
On branch master
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
        modified:   mi archivo.txt
no changes added to commit (use "git add" and/or "git commit -a")
C:\Users\servi\OneDrive\Desktop\Taller>

modified:   mi archivo.txt me lo muestra en rojo porque no paso a la staging area donde lo controla antes de un paso al repository

git commit -a es para agregar

primero git add y luego git commit -m 

C:\Users\servi\OneDrive\Desktop\Taller>git add .
C:\Users\servi\OneDrive\Desktop\Taller>git status
On branch master
Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
        modified:   mi archivo.txt
C:\Users\servi\OneDrive\Desktop\Taller>

y ahora hago un segundo commit

C:\Users\servi\OneDrive\Desktop\Taller>git commit -m "segundo commit"
[master dc9fd8b] segundo commit
 1 file changed, 3 insertions(+), 1 deletion(-)
C:\Users\servi\OneDrive\Desktop\Taller>

Ahora abro la carpeta taller en VSC, y alterno el uso delcontrol del código fuente 3 círc atados.
Si modifico el archivo aparece la letra M a la der del nombre del archivo
Luego del modificado lo tendría que agregar al area de staging

Entonces lo mismo que hacía con el gid add, lo hago ahora en VSC con el signo +, primero observo que está debajo de Cambios y luego de hacer + pasa al área de staging
Cambios Staged
Ahora le puedo hacer un commit, seleccionando boton azul Confirmación, arriba del botón azul y bajo Cambios, escribo tercer commit

4113

Ahora al archivo nuevamente modificado en VSC, con contenido
hola a todos
como estan esto es una prueba
de como se modifican los archivos
aparece en la zona de tercer commit, con la letra M, si lo quiero pasar a la zona de staging presiono el signo ´+ que equivale a un git add . de la terminal.
Salio de la zona de cambios y pasó a la zona de staging

Como ya esta en la zona staged le puedo hacer un commit, presionando el botón azul de confirmación poniendole arriba el nombre del commit, es decir le ponemos tercer commit

Instaló la extensión de nombre 

						Git Graph

, y si yo hago un hoover sobre la línea superior a nombre que dice Cambios, aparecen varios íconos, al extremo derecho, se ve el ícono similar al de la extensión.
Clic en él y veo de manera gráfica lo mismo que tenía en el panel izquierdo con el ícono de Git, que son 3 círc o nodos conectados. 

¿Sí? Entonces, cuando ustedes se generan una cuenta en GitHubat, que les recomiendo que lo hagan, van a poder empezar a eh subirse cosas que tengan localmente en esa cuenta o incluso hacer lo que se conoce como un fork.
Un fork es copiarse el repositorio de otra persona que la tiene en la nube en en el mismo eh GitHub, copiárselo en en su usuario. En este caso, yo estoy con el usuario mío de Ofacito, pero estoy eh teniendo acceso, como soy colaborador del centro, tengo acceso también a esto. Sí. Entonces, acá, ¿qué qué van a tener? van a tener un archivo, una un repositorio que yo les voy a ir subiendo por clase los códigos que vamos a ir usando.

¿Sí? Entonces, una manera de que ustedes puedan ir trabajando todos estos códigos es justamente haciendo uso de los repositorios. Entonces, ¿cómo podemos trabajar con esos repositorios? ¿Cómo puedo bajarme un repositorio que está en GitHub? Hay un comando que se llama git clone. Git clone lo que permite es sincronizar todos esos archivos, toda esa carpeta, ¿sí? Y meterlo dentro de mi máquina.

¿Sí? Entonces, para poder hacer eso, lo que necesitamos es esta dirección que yo les acabo de pasar, que es la dirección del repositorio en GitHubat. ¿Sí? Entonces, yo me voy a copiar esa dirección que es la que les acabo de pasar. también se puede bajar como si fuese un zip y abrir el zip. Sí. La ventaja de hacerlo esto con con clonarlo es que estamos manejando los comandos y estamos trabajando de una manera un poco más profesional y haciendo esos controles con el ZIP.

También vamos a bajar el repositorio e lo descomprimimos y lo vamos a tener, pero no estamos haciendo el uso de de Git. Sí, lo estamos usando con como un zip. 
https://github.com/centrograduadosFIUBA/IAPythonPrincipiantes.git

---------------------------------------------------------
 Bueno, entonces eh ¿qué podemos hacer? Por ejemplo, si yo estoy en mi usuario, yo podría hacerme una copia exacta en mi GitHub dentro de lo que es el eh el entorno en la nube. ¿Sí? Entonces, ¿cómo hago eso? Acá con un fork.
Yo puedo venir acá y esto le hago clic a este botoncito  que dice fork, y me va a decir se te va a copiar este mismo repositorio en tu usuario. Entonces yo le hago un clic acá y me va a decir el nombre de usuario, la copia del repositorio, que le voy a poder cambiar el nombre si quiero o no, y hacerme una copia exacta de lo que está ahí. Es un fork. ¿Sí? 

Entonces, me hago una copia exacta, le hago un crear y entonces dentro de mi usuario ahora voy a tener un IA Python para principiantes que va a ser una copia exacta de lo que tiene el otro repositorio, pero ahora esta es mía. Entonces, yo acá sí le voy a poder agregar, quitar, modificar, lo voy a
poder sincronizar con lo que haya hecho el centro de graduados. Sí, en el que es el del centro de graduado, si el centro de graduados no me da permiso, no puedo modificarlo, solamente puedo bajarlo. Sí. 

Y y mirar cómo está hecho. Entonces, depende lo que yo quiera hacer.
Si yo quiero tener una copia para poder manipularla a mi gusto, la puedo eh manejar como si fuese un fork. Sí. Y siempre voy a poder sincronizar el fork. Si hay si ellos en el centro de graduados hicieron un cambio, puedo acá hacer un sync y automáticamente se me va a ir sincronizando y a la vez yo voy a tener permisos de trabajar con este archivo. Sí, con este repositorio. Esta es una forma. Sí, Fer.
Eh, y esto me avisa que se hizo un cambio. Claro. Acá vas a ver si estás al día o no. Acá dice que estás al día. Y si hay cambios te va a decir, "Che, hay tantos comits que ellos hicieron que vos no tenés." Entonces podés sincronizarlo, por ejemplo. Okay. Entonces, por ejemplo, el proyecto genera un repositorio y lo comparte con todos los integrantes del proyecto y todos los integrantes se hacen su fork.
Sería una forma, una buena forma de trabajar, ¿sí? Porque vos podés manipular el for sin interferir en lo que está haciendo el proyecto. Sí. Okay. Pero digamos alguien lo tiene que generar y compartir. Exacto. Okay. Sí. Eh, hay es mucho más amplio todo esto. Yo le estoy dando una introducción nada más. Sí. Esa es una forma de trabajar y yo después de acá puedo hacer lo mismo. Ahora, fíjense que la dirección cambia.
Ahora es mi usuario con el nombre de repositorio que yo le haya puesto. Sí. Lo que me puedo bajar ahora. Esto es hacer un fork, lo otro es clonar. Sí, clonar es bajárselo a su máquina. se pueden bajar su versión, que si ustedes tienen permiso la van a poder mantener sincronizada también local y y remoto, así como vemos acá en la en la imagen usando estos comandos de Git Push es pasar lo que tengo en local, pasarlo al remoto y con gitol lo que tengo en remoto se sincroniza con el local subo o bajo cambios, pero tengo que tener permisos en ese repositorio.
tiene que ser un un repositorio que yo sea colaborador o que sea un repositorio mío para poder hacer uso de estos comandos. Si es un repositorio que no es mío, bueno, hay otros comandos y otras formas de trabajar que son los famosos pull request, donde yo le pido una modificación y eso lo tiene que aprobar alguien para poder incorporarlo, pero bueno, eso ya es un trabajo más colaborativo y de ramas, ¿sí? Entonces, si ustedes quieren poder mantener esto con git push, lo que hacen es subir lo que tienen en local a su repositorio y
con gitol lo que hacen es bajar lo que está en el repositorio remoto a el repositorio local. Pero para poder hacer eso, primero tuvieron que haberse clonado localmente ese repositorio, ¿sí? Entonces, cuando ustedes se clonan el repositorio, si es de ustedes, van a poder hacer estos comandos de sincronización.
Si es un Si de otra persona, cuando quieran colaborar con esa otra persona, van a tener que pedirle que incorpore algún cambio. Esa es la diferencia. Sí, eso después lo vamos a ver más adelante. No quiero no quiero ahondar mucho en eso porque quiero que nos quede tiempo para ver la parte de programación orientada objetos. Sí, Fer.
Y el que genera el repositorio sabe, digamos, ve a quién se lo compartió. Sí, sí, sí, sí, sí. Si vos vos cuando generás un repositorio en la nube, lo puedes eh generar privado o público. Si lo dejas público es de lectura para cualquiera y nadie te puede incorporar cambios, salvo que vos lo autorices. Si lo dejas privado, solamente lo pueden ver las personas que vos nombres como colaboradores.
Pero yo veo que vos que vos estás conectado y te los bajaste, una cosa así o Claro. Okay. Okay. Sí. Eh, cuando uno lo deja público es es de lectura para todo el mundo. Es código abierto, lo puede ver todo el mundo. Cuando uno lo deja privado, solo uno lo puede ver y puede seleccionar qué usuarios de GitHub pueden eh verlo y trabajar y le puede dar permisos de incorporar, permisos de quitar.
Pero bueno, eso ya es un trabajo colaborativo que es mucho más avanzado. Yo hoy lo que les quería dar era esta introducción y como quiero que empecemos a trabajar con Git, sí, yo les armé ese repositorio que acabo de hacerme un fork. Sí. Y lo que voy a hacer ahora es en vez de clonarme, eh, que también lo podemos hacer, en vez de clonarme lo del centro, me voy a clonar este fork que me acabo de hacer.
Se puede hacer de las dos maneras. Sí. Eh, veo una manito levantada. Orfelia. Sí, Omar, te consulto. Eh, acá cuando vos dijiste que se puede sincronizar el for que tenemos en estamos los dos, si hay dos partes, por ejemplo, el centro de graduados hace una sube un archivo, lo modificando cuando haces sincronización del fork, lo único que haces es bajarte los cambios.
Y pero si yo modifiqué el archivo en tu en tu fork, en tu copia de en la nube se sincroniza con tus cambios. Lo único que haces es incorporar lo que haya yo hecho el centro. Ah, okay, perfecto. Listo. Gracias. Sí, no tenés permiso de escritura en la del centro, solo en tu forma. Esa es la diferencia. Ahí está. 

Buenísimo. Ahí va. Eh, voy a compartir el el navegador, así ven de lo que estoy hablando.
Sí, cuando ustedes le hacen clic acá, yo acá me hice un fork y estoy, esta es una copia, es un forkit de la del centro de graduados. Yo puedo sincronizar los cambios, ¿si? Y me puedo bajar todo lo que haya hecho el centro de grado y lo puedo compartir acá. Y lo que hago es juntar lo que ellos hicieron con lo que yo venga haciendo. Sí, si lo manejo con el fork, si lo manejo directamente con el centro de graduados, fíjense que no tiene esa opción acá.
Simplemente lo que puedo hacer es, salvo que ellos me den permiso de escritura como colaborador, lo único que puedo hacer es bajármelo. Sí, esa es la diferencia. Les cuento para que sepan, ¿sí? que que están estas opciones. Entonces, ¿qué vamos a hacer? Me voy a bajar, por ejemplo, ahora voy a trabajar con con el fork. Sí, con este fork me voy a bajar ahora mi esta dirección.
Voy a ir a la terminal en la máquina virtual. 

Voy a minimizar el el visual. 

Sí, que ahí teníamos ese mi taller. Lo voy a voy a cerrar este temporalmente para que no me ocupe. Sí. Bueno, esto esto que que acabo de hacer lo voy a dejar acá y 

me voy a hacer una carpetita nueva. Le voy a poner curso para diferenciarlo y la voy a abrir en eh en una en una terminal.
Sí, en este caso, como tengo Git, eh se puede abrir acá en directamente en la terminal. También es una terminal como la de la de DOS, la la común, solo que aparece con estos colores y me aparece acá el simbolito. Sí, esa es la diferencia, pero lo podemos hacer en cualquier terminal, lo vamos a poder ejecutar.
¿Sí? Entonces, yo me voy a abrir acá, lo voy a abrir con el explorador para que vean lo que va a suceder. Y parado en este en este lugar, lo que voy a hacer es un CMD para abrir la terminal y voy a escribir git clon y le voy a pegar la la dirección, ¿sí? 

Que eh que teníamos de el repositorio. Sí, me voy a ir a la a la página web de de mi fork. Voy a venir acá y le voy a decir copiar.

Sí, me copio la dirección, la copio, vuelvo al entorno de de trabajo que que veníamos trabajando. Sí. Y le pongo 

git clone y pego esa dirección.

git clone https://github.com/centrograduadosFIUBA/IAPythonPrincipiantes.git

Fíjense lo que va a suceder en esta carpetita. dentro de la carpeta curso. Cuando yo le doy un enter, lo que va a suceder es lo siguiente.
Está medio lenteja. Vamos de nuevo. Ahí dice clonando el repositorio. me generé una carpeta y me agregó todo lo que tenía ahí adentro. Fíjense que me generó una carpeta con el nombre del repositorio y todos los archivos y, incluso tengo el archivito oculto de Git. 

C:\Users\servi\OneDrive\Desktop\curso>git clone https://github.com/centrograduadosFIUBA/IAPythonPrincipiantes.git

Cloning into 'IAPythonPrincipiantes'...
remote: Enumerating objects: 76, done.
remote: Counting objects: 100% (76/76), done.
remote: Compressing objects: 100% (63/63), done.
remote: Total 76 (delta 10), reused 66 (delta 7), pack-reused 0 (from 0)
Receiving objects: 100% (76/76), 22.03 KiB | 550.00 KiB/s, done.
Resolving deltas: 100% (10/10), done.

C:\Users\servi\OneDrive\Desktop\curso>

Sí, si ustedes hicieron lo mismo, ya van a tener todo disponible ahí para que trabajemos ahora y hagamos las pruebas cuando veamos la parte de programación orientada objetos.
Entonces, yo ahora puedo venir acá, botón derecho, abrir con Visual Studio Code 

y ahí tengo los códigos si los quisiera usar. Si no lo quiero abrir de esta manera, estoy en la clase 11 y hay 12 y más, puedo abrirme directamente el repositorio, 11 solamente voy a a carpeta curso, del escritorio y seleccion lacarpeta 11 y abrir con code.

Y fíjense que acá tenemos una carpeta de la clase 11, un git ignore. Este git ignore es para poder escribir qué cosa yo no quiero que Git les haga seguimiento para no tener que estar y yo poder hacer un git ad y no tener que estar escribiendo archivo por archivo.
Yo puedo hacer un git ad punto que le haga seguimiento a todo menos a lo que está acá dentro. ¿Y qué le puse acá? Las carpetas Bend, las carpetas M. que son los nombres que solemos usar para los entornos virtuales, por ejemplo. Sí. Y si me voy a ver acá, vamos a ver todo el historial de los cambios que yo le fui haciendo. Sí.
Y acá vemos que como esta carpeta es un clon de lo que está en la nube, tengo eh el puntero, o sea, el lugar en que estoy en la nube, en qué lugar estoy. Justo estoy en el tercer comit y localmente en qué lugar estoy. Sí. Entonces están sincronizados el directorio de la nube con mi directorio local. Por eso vemos acá la nubecita rosa al mismo nivel que este iconito que dice M.
Si yo ahora hiciera alguna modificación a estos a esta carpeta, ¿sí? Por ejemplo, y como esto es un fork y no estoy tocando el del centro de graduado, lo voy a poder sincronizar sin problema. Vamos a suponer que vengo acá a un archivito, voy al ritmi y le agrego soy Omar. Sí, estoy modificando un archivo. Ah, ya. Ahí va. Lo salvo. Entonces ahí me dice, "Tenés una modificación.
Este archivo está modificado. Si me voy acá a la parte gráfica dentro de Visual, lo que es Git, me dice, "Che, hay cambios en ese archivo. ¿Lo querés agregar al staging?" Bueno, entonces lo agrego al staging. Ya está. Ya no no figura como cambio pendiente, está como en temporal.
Y ahora le puedo agregar un commit y le voy a poner agrego mi nombre. Le hago un commit y fíjense que ahora si yo me voy acá a la nube está mi m local que tiene un commit más y el de la nube no tiene esto. Sí, fíjense que la nube quedó por debajo, la rama de la nube quedó por debajo y la mía quedó un commit más.
Y acá me dice, lo que estás haciendo es querés sincronizarlo con lo que está en la nube, con lo que está en el repositorio remoto. ¿Qué estamos haciendo acá? Lo que estamos haciendo, estamos en esta instancia. Como yo me cloné un repositorio remoto a mi local, ahora tengo la posibilidad de hacer git push o de git pull, que es bajarme los cambios. Entonces, yo lo que voy a hacer ahora es un git push.
Voy a subir este cambio que acabo de hacer. ¿Cómo me voy a dar cuenta de eso? Si me voy al navegador, vamos a ver que acá dentro, ¿sí? En este archivito, le voy a dar un F5 para que se refresque. Vamos a ver que tiene tres commits. El último fue hecho el día de ayer, pero acá no tiene esa modificación. Sí.
Entonces, cuando yo vaya ahora al visual y le diga, "Sincronizá, subí el cambio, lo que estoy haciendo es un push. Sí, fíjense, a un push sincronizado, me va a decir, esto va a sincronizar hacia el repositorio. Le voy a dar que sí. Estos dos se van a poner al mismo nivel. Acá me está diciendo, bueno, que me que que se quiere sincronizar.
Tengo que conectar, ¿no? Porque acá no la había usado nunca la cuenta. La tengo que conectar. Ahí me dice que ya está eh autenticado. Perfecto. Ahora ya puedo cerrarlo. Para eso tuve que tener la cuenta en GitHub. Y ahora fíjense que me quedó ya sincronizado. Y si yo, no sé si llegaron a ver el navegador, no sé si lo estaba compartiendo, pero la primera vez me abrí una ventanita en el navegador, sí, acá que me decía que había que sincronizarlo.
acepté la sincronización de la del visual, la autoricé a que se conecte al GitHub y a partir de ahora si yo le hago acá refresco, vamos a ver que ahora tengo cuatro commits. Uno que hice hace 2 minutos y me quedó actualizado esto. ¿Sí? Y se fijan acá, yo tengo una diferencia con el del centro de graduados. Tengo un commit más. Sí.
Y acá estoy mirando esa sincronización. Si yo quisiera sincronizarlo, le tendría que pedir al centro de graduados que agregue esto. Pero bueno, ya es otro trabajo colaborativo. Sí. Entonces, tanto si yo modifico acá eh yo acá también puedo modificar, por ejemplo, el Ritmi. Hola, soy Omar Facito. Estoy modificando desde el remoto.
Hago un commit. El commit dice update del Redmi. Listo, ahí se actualizó. Ahora, cuando yo voy a a la máquina, lo que va a suceder si hago, si refresco acá, ¿no? Para ver, voy a ver que eh voy a tener distintas eh puedo hacer hacer un pull, ¿sí? Un fetch, es decir, eh ver qué cambios subo. Entonces, puedo bajarme, dice, agrego mi nombre.
Si refresco acá, me va a decir de que tengo un un cambio. Sí, fíjense que ahora me dice, hay un cambio, hay un pull pendiente que tenés que bajarte. Lo querés bajar, fíjate que la nube está más avanzada de lo que vos tenés. Y acá está el commit. Le digo, sí, lo quiero sincronizar. Fíjense que acá en el RMI no está ese texto, pero si yo ahora lo sincronizo, ¿sí? Ahora ya tengo la misma versión de lo que está hecho en remote.
Sí, ahí hicimos todos los comandos básicos de Git. Sí, vamos bien. Esto requiere practicar, requiere probar. Sí. Eh, no sé quién había hablado. Yo que dije mucha práctica porque tiene mucha Sí, sí, sí, sí, sí. Yo les dejé en en este grafiquito que les en este grafiquito que les compartí, sí, están los cinco comandos que más van a usar.
Git ad, git commit, git push para subir el remoto, git pull para bajar y en caso de que hayan puesto algo en temporal y quieran sacarlo, git reset. Sí, pero bueno, eso es esa es la introducción que les quería dar con Git para que vean qué es lo que estamos trabajando. Y ahora vamos a empezar a trabajar los archivos. Sí, en este repositorio que yo les les acabo de de mostrar, vamos a ver lo que es programación orientada a objeto.
Todos los ejemplos que vamos a utilizar, yo se los dejé en ese repositorio. Entonces, ¿qué voy a hacer a partir de ahora? Les voy a dejar una carpetita en ese repositorio. Ustedes lo único que van a tener que hacer es sincronizarla. Eh, les voy a dejar una carpetita por cada clase con los códigos. ¿Sí? Entonces ahí van a van a poder ver los códigos de Python y los vamos a compartir de esa manera.
¿Sí? Entonces, ahora clase 11, acá tenemos todos los eh archivos que vamos a usar en la clase de hoy. ¿Sí? Entonces, vamos a cerrar momentáneamente el temario de de Git. Más adelante vamos a seguir retomándolo. Eh, usen chat GPT para preguntar qué es una rama, qué es esto, qué es lo otro para poder ir familiarizándose.

				programación orientada a objetos

Eh, no hay mejor manera de aprender a usar algo que metiendo man. ¿Sí? Entonces, ¿qué vamos a hacer ahora? Vamos a hablar en este ratito que nos queda sobre una introducción a programación orientada a objetos y en la próxima clase vamos a ampliar mucho más esto de programación orientada a objetos. 

Entonces, dentro de la carpetita de la carpeta del repositorio que ustedes cuando se lo clonen y lo tengan eh eh localmente para trabajarlo con el visual, van a poder trabajarlo.
Y acá les dejo todo lo que vamos a ir usando el día de hoy. En la carpeta clase 11 van a tener todo. Sí. La clase 12 van a tener lo de la clase 12 y así. Entonces vamos a ir a la presentación. Se va a bajar todo conjuntamente, no hay que bajar uno por uno. Se va a bajar, ¿no? No, por eso ustedes ustedes lo único que van a tener que hacer es un pull, un un push, o sea, bajarse, sincronizarlo.
Si ustedes ya lo tienen guardado en un lugar, a ustedes les va a aparecer cuando se paren acá les va a aparecer de que yo les agregué algo. Entonces, ustedes se lo bajan y automáticamente van a tener ahí eh localmente también. Sí, gracias. Cuando decís clonen es el fork. Sí, el fork.
O cuando vayan al fork les va a decir, eh, a ver, para, voy a ir al fork. Porque vos dijiste, se puede hacer un fork o se puede clonar. Exactamente. Lo que puede, si van a usar el fork, es lo que les recomiendo para que ustedes puedan manejarlo de manera independiente las modificaciones que yo haga.
Cuando ustedes hagan el fork, lo que les va a pasar, yo acá estoy en este es el for del centro. Cuando yo haga una modificación en el for, a ustedes acá les va a parecer de que hay cambios. 
Por ejemplo, cuando agregue la carpeta 12. Entonces, ustedes ponen acá sincronizar con sincronizar el fork. Acá me dicen, no hay ningún commit, estás al día, ¿ves? Pero ustedes les va a decir, si yo le subo un commit al fork, ustedes van a les va a aparecer acá para que hagan sincronizar el fork y ahí van a poder bajárselo después al local. Sí, la clase que viene vamos a hacer ese trabajo. Ahora que si ya tienen el fork, les voy a enseñar cómo llevar del repositorio original al fork y cómo llevarlo del fork a su local, pero lo vamos a hacer la clase que viene. Sí. Okay. Sí. Este, yo acabo de de crearme una cuenta en Ghub. Eh, lo que quiero saber es cómo reconocer que estoy en mi cuenta y no en la del Centro de Ingenieros, porque no me doy cuenta bien todavía en dónde tengo que ver cuándo es la mía y cuándo es la de ustedes. Te va a aparecer el nombre de usuario acá arriba, mira.
Ajá. Ah, okay. Okay. Y después aparte vas a ver el loguito acá a la derecha tenés tu perfil. Y a derecha mi perfil en GitHub. En GitHub, exacto. Ah. Okay, está bien. 

Creo que tengo una genérica porque todavía no subí ninguna. Entonces, sí, sí, sí puede ser.

Si no subiste ninguna foto, nada, es yo, porque puse una foto mía, pero sí te va a aparecer el nombre de usuario acá. Okay. Okay, gracias. Acá siempre vas a ver que dice usuario barra repositorio en donde estás parado. Entiendo. Entonces, si está mi usuario, lo que estoy viendo está en mi eh en mi repositorio. Exacto.
Si yo ahora me voy acá, fíjate, ¿ves? Acá estoy en el repositorio del centro de graduados, pero en el nombre repositorio con mi usuario. Lo puedo ver porque es público y estoy mirando el otro repositorio para saber siempre en dónde estás. Es este que está acá. Es el de la derechita. Perdón. Justo mira la otra pantalla. ¿Qué? ¿Cómo te fuiste de un repositorio al otro? Como acá abajo dice que este es mi repositorio, que es un fork del centro de graduados, si yo le hago clic acá, me salto al original. Okay, okay, entiendo.
Sí, sí, sí. Pero bueno, yo hoy quería presentarles esto porque quiero que se acostumbren a usar git porque me parece que es una buena práctica como programadores y que les va a servir. Sí. Entonces, es una manera de de obligarlos a que vayan practicando también esto. Entonces, vamos a arrancar con el temario de programación orientada a objetos.
Sí, para eso voy a volver a la presentación y cuando haya alguna práctica vamos a tomar los códigos en el visual. Sí. 

				Programación orientada a objetos. 

¿Qué es esto de orientado a objetos? La programación orientada a objetos o p o es un paradigma de programación. ¿Qué es un paradigma? Es una forma de organizar el código y todo lo que nosotros escribimos y una manera de programar.
que tiene cierta organización y ciertas reglas. 

En este caso, la programación orientada objetos está basada en un concepto, ¿sí?, que todo ronda alrededor de objetos. 

¿Qué es un objeto? En lugar de tener lo que vemos en el paradigma lineal, la programación lineal, donde teníamos un control de flujo y nosotros teníamos el if para bifurcar las funciones para hacer algo repetitivo.
Bueno, en programación orientada a objetos, un programa va a estar compuesto por muchos objetos individuales y cada uno de esos objetos van a tener ciertas capacidades y van a poder hacer ciertas tareas, ¿sí?, que son específicas de ese objeto. Entonces, estos objetos van a formar parte del programa y van a empezar a cooperar entre sí, van a empezar a mandarse mensajes entre sí y hacer tareas de manera conjunta.

Entonces, cada uno de estos objetos en realidad tienen cierto comportamiento, ¿sí? van a tener un 
estado, van a tener unas 
variables y van a tener un 
comportamiento que le permite relacionarse con otros objetos dentro de ese ecosistema del programa.

 Ahora, cuando veamos bien los gráficos se van a dar cuenta de qué les estoy hablando, ¿sí? Pero orientado a objeto es en vez de pensar una secuencia lineal de programación vamos a tener objetos que tienen capacidades y que pueden hacer tareas.

Un objeto puede ser la representación de una entidad de la vida real, 

¿sí? Por ejemplo. Entonces, un objeto lo que podemos hacer es crearlo usando lo que se conoce como clase o plantilla, ¿sí? Un un template de lo que es un plano, ¿sí? De lo que es ese objeto de cómo construirlo, un molde.

¿Sí? Entonces, una clase va a representar todas las características que debería tener ese objeto y después nosotros vamos a poder generar tantos objetos como necesitemos de esa clase. ¿Sí? 

Ahora vamos a ver bien puntualmente es cada una de estas palabras que les estoy nombrando. Python en sí es un lenguaje de programación orientado a objetos. ¿Por qué? Porque dentro de Python todo es un objeto.

Cuando nosotros estuvimos trabajando con Python, vimos, por ejemplo, listas. Sí, si nosotros vamos a la documentación de las estructuras de datos, por ejemplo, las listas, nosotros estuvimos usando el objeto, ¿sí?, de la clase lista y vimos que teníamos distintos métodos que podíamos usar. teníamos remover, pup, ordenar, extender, insertar.

	Entonces teníamos lista punto y lo que queríamos usar. 

Sí, nosotros declarábamos una variable, por ejemplo, la variable lista y después usábamos los métodos o las acciones que tenía ese objeto. 

Es decir, nosotros ya venimos usando el paradigma de objetos al usar el lenguaje Python. Lo mismo va a suceder cuando trabajemos con alguna librería. Por ejemplo, la librería SQLite.

SQLite es una librería que nos va a permitir trabajar con la base de datos SQLite. 

Yo voy a generar una instancia de un objeto de esa base de datos. 

Sí, voy a poder generar, por ejemplo, de el objeto SQL, voy a usar el método conexión. 

Y el método connect me permite conectarme una base de datos. 

Entonces, voy a generar una conexión a esa base de datos.

O puedo pedir un cursor que vemos acá, ¿sí? 

Que lo que hace es ejecutar una consulta a la base de datos. 

Entonces, tengo un objeto para hacer consultas. ¿Sí? 

Entonces, un objeto en realidad es la representación de una entidad, de algo que puede tener un estado y que puede tener también características o funciones a usarse.

Lo que vamos a hacer cuando estemos resolviendo problemas en realidad es hacer que todos estos objetos se comuniquen entre sí. 

Nosotros cuando estábamos programando la programación lineal, lo que hacíamos era teníamos un dato, ese dato se lo dábamos a una secuencia de programa, se procesaba todos esos datos y eso lo devolvía, nos devolvía una salida.

A veces esto lo encapsulábamos incluso dentro de una función que para poder usarlo de manera repetitiva, ¿no? 

"Omar Fazzito
En la programación secuencial o funcional tenemos un control lineal del proceso. Manejamos estructuras de control para direccionar el flujo.
O bien encapsulábamos en funciones cierta parte del código que utilizaríamos repetidamente."

Entonces, en la programación secuencial, que es otro paradigma, que es el que veníamos usando hasta ahora, sí, nosotros podíamos armar toda la secuencia paso a paso.
Si que que empezábamos a armar funciones, teníamos que esas funciones reciben un dato y devuelven algo. ¿Sí? Ahora, eso que nosotros hacíamos como función y que encapsulábamos todo eso y para que esa esa parte del código no la tuviéramos que escribir todo el tiempo, ¿sí? 

Podemos usar un concepto similar con los objetos. 

Un objeto sí va a estar compuesto por un poco de código y un poco de datos que va a guardar.
¿Qué datos va a guardar? datos propios, datos autónomos de su estado, de lo que es ese objeto y el código va a ser cosas que puede hacer ese objeto. 

Entonces, un objeto en realidad es un poco de código más un poco de datos. 

El código va a ser tareas, comportamientos, funciones que nosotros les vamos a programar y los datos van a ser variables o datos propios de ese objeto que van a ir guardándose y que van a a ser parte del objeto.

Por ejemplo, supongamos que tenemos Sí, Alejandro, el hecho de que no sea lineal significa que puede interactuar en órdenes diferentes. Exacto. Okay. Exacto. Que yo ya no estoy pensando una secuencia lineal interrelacionado, digamos. Ahora, ahora lo vamos a ir viendo.
Cuando nosotros tenemos un problema muy complejo, por lo general lo que hacemos es dividirlo en problemitas más simples y empezar a atacar cada uno de esos problemitas más simple. Sí, supongamos que queremos hacer una tarea bastante compleja y armar un programa. Si ese programa tiene una secuencia de pasos que nosotros tuviésemos que hacer, lo que vamos a tratar es de modelar cada una de esas responsabilidades, cada una de esas tareas en pequeños programitas.
¿Sí? Cada uno de esos pequeños programitas, cada una de esas partes, cada una de esas tareas, la podemos representar como un objeto. ¿Sí? 

Entonces, este es un enfoque muy importante de la programación orientada a objetos. es dividir un problema grande en partes más pequeñas y comprensibles con responsabilidades bien especificadas.

Entonces, un problema grande podemos hacerlo y separarlo en pequeños problemitas más chiquitos. Por ejemplo, e tomar los datos de una lista, ordenarlos de mayor a menor y mostrarlos en pantalla. Entonces, yo podría tener un objeto que lo que hace es eh ser la lista, otro objeto que lo que hace es ordenarse, otro objeto que lo que haga es mostrarlo en pantalla y otro objeto que haga otra tarea.

Entonces, voy a tener un ecosistema que cada uno va a estar representado y va a tener ciertas capacidades. ¿Sí? 

Y lo que voy a lograr con esto es poder resolver con pequeños programitas una tarea muy compleja, ¿sí? 

que solamente se va a dedicar a eso. 

"Un aspecto clave del enfoque de objetos es dividir el problema en partes más pequeñas y comprensibles."

En los sistemas lo que se suele hacer es, por ejemplo, tengo una parte del sistema que se encarga del logueo de usuarios,
 tengo una parte del sistema que se encarga de levantar pedidos de ese usuario,
 tengo otra parte del sistema que se encarga de facturar ese pedido, 
tengo otra parte del sistema que se encarga de e, no sé, guardar eh el stock de después de que se facturó. Sí. 

Entonces, cada una de esas partes va a estar compuesta por varios objetos. 

¿O entonces, ¿qué me implica esto? 
Que voy a tener, por ejemplo, un objeto cliente, 
voy a tener un objeto producto, 
voy a tener un objeto factura. 

Y cada una de estas entidades va a tener responsabilidades, va a poder hacer distintas cosas. Lo que yo hago dentro de un sistema es que empiecen a relacionarse entre sí.

Sí, Alejandro. Bueno, entonces los objetos lo que hacemos es crearlos muteado, pero no me di cuenta. Si hay objetos dentro de otros objetos, o sea, si tenés grupos de objetos interrcionados, ¿no? Okay. Sí, puede haber grupos de objetos, pero eso es otra cosa. Ahí estás hablando en una librería. Sí.

Entonces, los objetos en sí lo que hacemos es crearlos para para poder usarse. ¿Sí? ¿Y cómo es que se usan? Bueno, van a empezar a mandarse mensajes entre sí, se van a empezar a pasar datos entre sí. Sí, eso de pasarse datos entre sí me permite tener objetos de distintos tipos. 

Por ejemplo, hasta ahora nosotros estuvimos trabajando con Python usando muchos objetos que ya vienen en Python.

Usamos objetos del tipo cadena, objetos del tipo entero, objetos del tipo diccionario, objetos del tipo lista. Sí. 

Y en nuestros programas lo que hacíamos es tomar un diccionario, pedirle al diccionario que nos diga que tenía dentro, según los datos que teníamos, se lo pasábamos a una cadena. Sí. 

Entonces, podíamos ir trabajando con objetos y usando los distintos métodos que tenían esos objetos.

Entonces, si pensamos al objeto como que está compuesto por una parte de código y una parte de datos, nosotros vamos a poder abstraer, decimos, un problema representándolo con un poquito de código y un poquito de datos.

 Es decir, cada objeto va a tener un comportamiento, una funcionalidad y va a tener algunos datos que van a ser propios de ese objeto.

Esto me permite hacer foco solamente en ese objeto y olvidarme del resto, de todos los demás detalles que son innecesarios. 
Es decir, yo puedo hacer foco en ese objeto y ese objeto tiene vida propia, tiene cierta funcionalidad, tiene ciertos datos y no me importa el resto.
Yo me puedo así como hacemos con las funciones, yo sé que esta función le manda un dato y me devuelve algo. Bueno, lo mismo podemos hacer con los objetos, ¿sí? 

Eso se llama abstracción. 

Yo puedo modelar un comportamiento, darle algunos datos y olvidarme del resto del sistema haciendo esa representación. 

Por ejemplo, puedo tener un objeto diccionario, que al objeto diccionario yo tengo métodos para agregarle datos, tengo métodos para leerle datos y después están los datos propios de ese diccionario.¿Sí?

 Ahora, yo una vez que ya tengo el objeto y que ya tengo programado cómo se comporta, no me interesa cómo lo hace internamente, después lo uso. Eso me permite abstraerme del código de cómo lo hace. Sí. 

Cuando yo tengo, por ejemplo, un objeto que me maneja el stock de mi inventario en mi sistema de facturación.
Bueno, yo sé que en algún momento cuando hago una venta le tengo que decir a ese a ese objeto, ¿sí?, a esa clase le tengo que decir, "Descontad el stock tal producto." ¿Cómo lo hace? No lo sé. Yo me abstraigo de eso. Me olvido, pero ya sé que está programado ahí adentro.
Lo único que sé que le tengo que mandar el mensaje, "Desconta uno, ¿sí?" Y él me va a decir, "Listo, se descontó. ¿Cómo lo hizo? Bueno, él se encargó de hacerlo. Entonces, yo me abstraigo de ese problema, lo programé una vez, lo resolví y ya está guardado en ese objeto. 

Y lo otro que nos permite la programación orientada a objetos es que puedo encapsular esos problemas y trabajarlo de manera independientes.

Es decir, yo puedo modelar un comportamiento de una entidad, de alguna cosa de la realidad a través de ese poder de abstracción, pero eso también me permite que los demás no vean y no se enteren qué es lo que está pasando ahí adentro. Solo saben que si le piden o le mandan un mensaje, ese objeto va a responder de cierta manera.
Saben cómo comunicarse con el objeto, pero ¿qué hace el objeto internamente? está encapsulado, no lo veo. Entonces estoy protegiendo esa lógica. Sí, yo sé que si quiero programar y pedirle cuál es el stock de tal producto, uso un objeto de la clase stock y le digo, eh, ¿cuánto tenés de tal producto? Y me va a devolver la cantidad.
¿Cómo lo hizo? ¿Cómo lo fue a buscar? ¿Dónde lo buscó? A mí no me interesa. Eso está encapsulado. Yo sé que le mando un mensaje y me responde de una manera. Sí. 

Entonces, acá acabamos de ver dos aspectos importantes de lo que es la programación orientada a objetos, encapsulamiento y abstracción. Sí, 

la abstracción es algo de la vida real, olvidarse de todo el resto y modelarlo en un objeto.

Y el encapsulamiento justamente protejo todo lo que está ahí adentro y el resto del sistema no tiene por qué interarse. 

Lo único que tiene que saber es cómo comunicarse con mi objeto. 

Ahora, ¿cómo hacemos esto de trabajar entonces con la programación orientado a objetos? Bueno, hay ciertas palabras que vamos a empezar a usar. 

Una es la de clase.

"CLASE: Una clase es una plantilla o un plano que define un conjunto de atributos y métodos que caracterizan a cualquier objeto de esa clase."

 La clase es una plantilla, es el plano que define cómo hago para construir ese objeto.
Un objeto va a tener atributos y va a tener métodos, ¿sí? Es decir, va a tener variables y va a tener funciones que puede hacer, pero eso lo tengo que definir. ¿Se acuerdan cuando definíamos una función y después la usábamos? Bueno, acaba para ser igual. vamos a tener que definir una clase y después la vamos a usar.

"CLASE: Una clase es una plantilla o un plano que define un conjunto de atributos y métodos que caracterizan a cualquier objeto de esa clase. "

-Esa clase va a tener eh dentro de su definición los métodos y los atributos de esa clase. -

"METODOS O MENSAJES: Los métodos son funciones definidas dentro de una
clase y se utilizan para realizar acciones específicas en los objetos creados a partir de esa clase."

Los métodos van a ser los mensajes, es decir, qué funcionamiento tiene, todas esas funciones predefinidas que van a estar dentro de esa clase y que se van a utilizar como acciones que va a poder hacer ese objeto. 
Si por ejemplo, tengo un objeto usuario. Sí.
ese usuario va a poder loguearse, ese usuario va a poder borrarse, ese usuario va a poder modificarse. Sí, esos son los mensajes, los métodos, las funciones que puede hacer el usuario.

 Ahora, ese usuario va a tener ciertas variables o ciertos campos que son propios. El nombre, el email, el apellido, el teléfono, si está logueado o no está logueado. Sí, esos son campos, son atributos, son variables propias.
de ese usuario, que también los hace distintos de otro usuario. ¿Sí? 

"METODOS O MENSAJES: Los métodos son funciones definidas dentro de una
clase y se utilizan para realizar acciones específicas en los objetos creados a partir de esa clase."

Entonces, dentro de esos eh atributos o de esos campos, vamos a tener dos tipos. 

--Unos que van a ser los atributos de instancia, es decir, los que pertenecen puntualmente a ese objeto y que lo hace diferente de otro.

--y los atributos de clase que por ser parte de esa clase sí les corresponde. 

Ahora, después vamos a ver en con algún ejemplo qué es esto de atributo de clase y atributo de distancia. Más adelante y la próxima clase lo vamos a ver más en profundidad. 

Lo que quiero que les quede es que 

un método es una función, 
un atributo es una variable. ¿Sí? 

Entonces, acá tenemos comportamiento, código en las funciones y propiedades o atributos que van a ser variables.

Lo otro que vamos a tener es el objeto en sí. 
El objeto es una instancia, decimos, de una clase particular. Sí, 

en Python todo es un objeto. Cuando nosotros generábamos un objeto de un tipo del tipo lista, le poníamos un nombre de variable, ¿sí?

 Y por ser parte de esa clase tiene un montón de funcionalidad, 

pero después a esa a esa lista le agregábamos valores, ¿sí? 

Y podía tener una lista, dos listas, tres listas. Cada una de esas listas que tenía es un objeto distinto.

Ahora vamos a ver la diferencia entre instancias. ¿Sí? 

La realidad es que eh los objetos dentro de Python es la base de todo el funcionamiento de Python. 
Cada cosa que usamos en Python es un objeto, desde los enteros, los flotantes, eh las estructuras más complejas como los diccionarios, las listas, las tuplas, todos son representadas como objetos y como tal tienen datos que le puedo incorporar y también tienen ciertos comportamientos o funciones asociadas.

Por ejemplo, sí, para verlo esto eh un poquito más en detalle, ¿qué es un objeto? ¿Qué es un instancia y qué es una clase? 

¿Qué es una clase en sí?
 La clase va a definir de manera abstracta, ¿sí? sin hacer específico, es simplemente decir cómo está compuesta esa clase. Es decir, vamos a tener ciertas características y ciertos campos que van a ser propios de esa clase.

"Define las características abstractas de una cosa (objeto), incluidas las características de la cosa (sus atributos, campos o propiedades) y los comportamientos de la cosa (las cosas que puede hacer, o métodos, operaciones o características). Se podría decir que una clase es un plano o fábrica que describe la naturaleza de algo. Por ejemplo, la clase Perro consistiría en rasgos compartidos por todos los perros, como la raza y el color del pelaje (características), y la capacidad de ladrar y sentarse (comportamientos)."

Por ejemplo, tenemos la clase perro. 
Sí, el perro va a tener algunos eh campos, algunas propiedades, algunos atributos puntuales. ¿
Qué atributos puede tener un perro? 
Bueno, puede tener una raza, un color, una edad. Esos son atributos de un perro.
¿Si? Entonces, yo acá estoy armando el molde de cómo voy a definir lo que es un perro. Entonces, la clase perro dice, "Tengo raza, color y edad." Ahora, el perro puede hacer distintas acciones, puede tener distintos métodos, puede hacer otras operaciones. 

¿Qué operaciones puede hacer un perro? ¿Qué acciones puede hacer un perro? ¿Qué métodos puede tener? Bueno, puede ladrar, puede sentarse, puede correr. Sí.

-Entonces, cuando yo defino una clase, estoy definiendo
 la forma, 
el comportamiento y 
qué cosas, 
qué propiedades, 
qué campos 
va a tener esa clase. 
Entonces, voy a definir una clase perro que va a tener atributos, raza, color y edad, y va a tener métodos, acciones, funciones que va a poder hacer. 

"Clase PERRO
ATRIBUTOS:
Raza
Color
Edad
METODOS:
Ladrar()
Sentarse()
Correr()

Entonces esta clase en realidad va a funcionar como un plano, como una fábrica de objetos. Sí, como si fuese un molde.

Entonces, yo tengo masa, supongamos que tengo galletitas, ¿no? 
Entonces, estiro la masa y después voy pasando por encima de ese de esa masa estirada, voy cortando con ese molde y voy generando distintas galletitas. Sí, voy a tener galletitas que son triangulares, 
galletitas cuadradas, 
galletitas en forma de estrella. 
Sí, pero ese molde es la clase y cada galletita sería un objeto.

Entonces, esta clase perro que estamos haciendo, yo la estoy definiendo con los rasgos compartidos de todos los perros. Todos los perros van a tener una raza, un color, una edad. Todos los perros van a poder ladrar. Todos los perros van a sentarse. Todos los perros van a correr. Sí.
Entonces, van a tener eso y lo que estoy haciendo es definir justamente esa entidad. algo de la vida real, sí lo estoy definiendo de algún de alguna manera, separándolo en atributos y métodos. Sí,

 Alejandro, eh, ¿cómo sabes cuáles son los atributos que necesitas para crear una clase? Y bueno, ahí está lo de tener poder de abstracción, es decir, poder modelar algo que yo necesite, que voy a tener que usar una variable. Ah, no hay no hay como una eh no no hay.
Vos puedes crearte el objeto que vos quieras. 
La puedes crear como quieras. Okay. Okay. 
Vos te creas el objeto que vos quieras. Vas a poner variables que vas a necesitar en el funcionamiento. 
Si a vos no te interesa eh largo de pelo en ninguna funcionalidad, no tiene sentido tener ese dato si no lo usas. 
El largo de pelo del perro.
¿Sí? Entonces, ¿cómo puede ser largo? ¿Corto, medio o largo? Ponele. Sí. Pero si yo ese dato no lo uso, ¿para qué lo voy a modelar? 
¿Para qué lo voy a a armar? Cuando nosotros estamos modelando, estamos armando una clase, vamos a poner atributos que yo necesite y vamos a poner funciones que yo necesite para resolver el problema. ¿Sí? Bueno, entonces estos son los datos.

Esta sería la parte de los datos y esta sería la parte del código.

 Sí, los datos son las variables, los atributos y el código serían los métodos.

 			¿Y qué es esto de hablar de una instancia? 

Bueno, una instancia es una vez es cuando yo ya declaro y uso esa clase, cuando fabrico el primer objeto. 


Sí, uno puede tener una instancia de una clase o un objeto en particular.
Esa instancia, ese objeto real que cuando yo ya lo creé en tiempo de ejecución, ¿sí? En en la jerga de la programación decimos que ese objeto es una instancia de tal clase. Por ejemplo, puedo tener a LAI que sea una instancia de la clase perro. ¿Sí? Entonces, LAASI como perro, como individuo, va a tener algunas variables y va a tener algún comportamiento, va a tener un estado.

"Uno puede tener una instancia de una clase o un objeto particular. La instancia es el objeto real creado en tiempo de ejecución. En la jerga del programador, el objeto Lassie es una instancia de la clase PERRO. El conjunto de valores de los atributos de un objeto determinado se denomina estado. El objeto consta del estado y el comportamiento definido en la clase del objeto."

Entonces ahí es cuando hablamos de variables de estado o variables de clase. 

Entonces, yo tengo la clase perro. Ahora, cuando yo instancio esa clase, cuando agarro el molde y lo pongo encima de la masa y levanto el molde y me quedó cortadita la galletita con la forma, acabo de instanciar, acabo de fabricar un objeto. Ese objeto va a tener un estado.
Sí, por ejemplo, LASI va a ser de la raza coli, va a tener un color marrón, va a ser de va a tener una edad de dos y va a poder ladrar, sentarse y correr. Estas variables son propias de una instancia. Es el estado actual de este objeto. Este objeto se describe con estos atributos y esta funcionalidad. La si es un objeto.
La clase perro es la definición de lo que es un perro. Sí, esa es la diferencia entre clase e instancia. Pero yo podría tener otro perro y le puedo llamar Tony. Tony va a ser otra instancia de la clase perro, pero va a ser otro objeto distinto. ¿Por qué? Porque tiene atributos distintos. Entonces, voy a tener en memoria la representación de dos perros con valores distintos, ¿sí? Y con funcionalidades que vienen propias de ser perro. Sí.
Por ser perros, los tres tienen raza, color y edad, pero cada uno tiene su valor, cada uno tiene su representación y cada uno es un perro distinto porque le estoy nombrando de manera distinta, pero los tres tienen funcionalidad en común. Los tres pueden ladrar, sentarse y correr. Por lo tanto, estas son funciones de clase que las las heredan, las tienen por ser de la clase perro.

Clase PERRO
ATRIBUTOS:
Raza
Color
Edad
METODOS:
Ladrar()
Sentarse()
Correr()

lassie
ATRIBUTOS:
Raza Collie
Color marrón
edad 2
METODOS:
Ladrar()
Sentarse()
Correr()

tony
Raza labrador
Color blanco 
edad 4
METODOS:
Ladrar()
Sentarse()
Correr()

Sí. Esto mismo pasaba cuando generábamos una lista. Cuando nosotros en memoria instanciábamos una lista, decíamos, creé una lista y le ponía el nombre lista de amigos, por ejemplo. Bueno, lista de amigos era del tipo lista y por ser del tipo lista teníamos un montón de métodos, pero esa lista tenía componentes internos distintos y la lista de amigos no era lo mismo que la lista de ingredientes para mis recetas, por ejemplo. Sí.

¿Se entiende la diferencia entre clase y instancia? 

La clase es una idea, algo abstracto, una definición y la instancia es cuando la creo y ya la la pongo en memoria con algunos valores específicos. Sí. 

¿Dudas, preguntas? Vamos bien. Muy bien. Gracias por la explicación. 

Entonces, objeto o instancia a menudo se suelen usar de manera indistinta, ¿sí? 
La palabra para poder eh instanciar una clase necesito crear un objeto.

El método, cuando hablamos de métodos, sí, son las habilidades que tiene ese objeto. Por lo general, vamos a nombrar los métodos con verbos. ¿Sí? 
Por ejemplo, cuando teníamos lazi, por ser de la clase perro, tiene la capacidad de ladrar, por lo tanto va a haber una función ladrar.
¿Sí? Entonces, ladrar va a ser uno de los métodos del objeto lá, pero también puede tener otros métodos, como habíamos dicho, sentarse, comer, ¿sí? Y todo eso van a estar programados, van a ser la parte de la programación de ese objeto. 

"TERMINOLOGÍA: "METODO"
Las habilidades de un objeto. En el lenguaje, los métodos son verbos. Lassie, siendo un perro, tiene la capacidad de ladrar. Así que ladrar() es uno de los métodos de Lassie. También puede tener otros por ejemplo, sentarse () o comer () o caminar () o correr(). Dentro del programa, el uso de generalmente afecta solo a un objeto en un particular; todos los perros pueden ladrar, pero solo necesitas un perro en particular para ladrar"

Entonces, generalmente cuando yo estoy e usando uno de los métodos que tiene ese objeto, solo va a afectar a ese objeto, no va a afectar a otro. Sí.

A por eso a ese tipo de métodos les decimos 

					métodos de instancia. 

¿Por qué? porque solamente modifica los valores, las variables, los campos de ese objeto, salvo que sea un objeto que una función o un método que haga que se comunique con otro, pero lo único no está modificándole al otro, le está mandando un mensaje.

Sí, supongamos que ladrar sea que un perro le está ladrando a otro, ¿sí? Entonces, bueno, ladrar sería la forma de comunicarse, pero no le está modificando los valores internos, solo le está mandando un mensaje. Sí. Es decir, todos los perros pueden ladrar, ¿sí? Pero no todos van a ladrar específicamente, solo lo va a hacer al que se está ejecutando en ese momento.

Entonces, el concepto de método y mensaje, ¿sí? La idea esta de ir pasándose mensajes entre objetos es también usado de manera indistinta. 

Método, mensaje se suelen usar como como sinónimos dentro de la programación orientada a objetos. Sí. 

Ahora, ¿cómo definimos una clase en Python? En Python ya existen algunos objetos.
Para eso voy a compartir ahora todo mi pantalla, así lo podemos hacer mucho más rápido. 

Permítanme abrir cmd. Voy a abrir una una terminal muy rápidamente para usar el shell de Python. Sí. A ver si puedo agrandar un poquito esto para que se vea mejor. Ahí se va a ver mejor. Y se acuerdan que yo puedo escribir Python y entrar al shell prom de Python.

x = 'abc'
type (x)
class 'str'>

la clase STR es justamente una definición de una clase. Cuando yo estoy generando el X, estoy creando un objeto del tipo stream y como objeto del tipo stram características, van a tener funcionalidades y va a tener eh campos que voy a poder usar.

type (2.5)
class 'float'>
Sí, si yo me voy a a lo mismo con un con un float y con un int, me va a pasar exactamente lo mismo. Yo voy a poder decir, por ejemplo, decme ahora el type, decime ahora el type de eh 2.5 para hacer el mismo ejemplo que tenemos ahí. Este es de la clase float, es decir, es una instancia de un objeto de la clase float.

todo el tiempo estuvimos usando clases y objetos dentro de Python. ¿Sí? 

Y cuando hago >>> dir(x),  x = 'abc'
  voy a ver que tengo distintos campos y tengo distintos métodos. Esos métodos son propios de esta instancia, de este objeto del tipo stream por ser de esa clase. 

Sí. con la palabra dir, con el con dir, puedo ver el comportamiento y la definición de cuáles son los métodos que tiene una clase. Sí, lo mismo me va a pasar con las listas.

Sí, yo genero una lista, hago el type de esa lista, voy a ver que es de la clase list. esa clase list, si yo le digo unir, voy a ver que entre un montón de cosas aparece el método appen, clear, count. El count, ¿qué me devolvía? Me devolvía cuántos elementos tenía la lista.
 El el sort, ¿qué me hacía? Me lo ordenaba. 
El reverse, ¿qué me hacía? Me lo daba vuelta. 
Me ponía el primero al último y me invertía el orden. Sí.
Lo mismo pasaba con el diccionario. Yo genero un diccionario. Sí, nosotros podemos trabajarlo de esa manera. 
Y acá lo que estamos haciendo, fíjense que acá estamos usando list paréntesis,  En vez de generarlo con, voy a hacer un i igual list, estoy usando un método. y= list () Este método list lo que estoy diciendo es creo quiero crear una lista, un objeto del tipo lista.

Yo puedo generar una lista poniéndole los elementos o simplemente diciéndole, quiero instanciar con esto que vamos a decir que es el constructor, ¿sí? El que instancia el objeto. Y yo acá puedo hacer un type ahora de ese i. Si hago un type de si, me va a decir que es de la clase lista. Y si hago un DIR DSI, me va a decir todos los métodos. que tiene esta lista.

= list()
>>> type(y)
<class 'list'>
>>>> dir(y)
['_add_',classclassdir_',doceqgetstategthashiterleLenreduce_exreprreeofstr
subclasshoc'insert', 'popremoverev

¿Sí? Entonces, fíjense que podemos crear objetos, lo podíamos crear en las listas, por ejemplo, armándolo por por definición o usando un método que crea el objeto. Sí, lo mismo va a pasar con el diccionario. Y el diccionario también tiene sus propios métodos.
teníamos el get que me permitía traerme un ítem,
teníamos key que me permitía traer todas las claves, ¿sí? 
Teníamos el values que me traía todos los valores, eso lo usamos. 
Y para crearlo, lo podíamos crear con los con los corchetes, con las llaves, perdón, o lo podemos crear usando un método de la clase DIC, que me permite construir un objeto simplemente diciendo dict y crear esto.
Este DIC que vemos acá es un constructor. Ahora vamos a ver más adelante qué es esto de un constructor. Sí, 
pero todo el tiempo estuvimos usando objetos dentro de Python. 
Vamos bien. Sí, sí. Okay. 

Entonces, vamos a hacer un ejemplo de una clase. Yo acá para definir una clase, así como en las eh en las funciones teníamos las palabras reservada def, en Python tenemos la palabra reservada class.
¿Sí? Entonces, yo puedo escribir class, el nombre de la clase. Sí. Y class va a ser una palabra reservada de Python. Es una es una palabra del lenguaje. No la puedo usar porque se me ocurre. Cada vez que yo pongo class, lo que le estoy diciendo es lo que sigue es el nombre de la clase. ¿Sí? 
En este caso, class party animal. 
Supongamos que se hace una una fiesta en la selva. Sí.
Y necesito una clase para contar cuántos animales van a la fiesta. Sí. 
Entonces, inicializo un atributo. Esta va a ser la clase para crear ese objeto. 
Entonces, ¿qué estoy haciendo acá? Estoy definiendo esa clase. Esa clase va a tener unos datos.

"

class es una palabra reservada
class PartyAnimal:
x = 0
def party(self):
self.x = self.x + 1
print("Hasta ahora", self.x)  # acá termina la definición de la clase
an = PartyAnimal() #esto es una instancia de la clase partyanimal dice que an es un objeto de esa clase que tiene un campo y una función
an.party()
an.party()
an.party()


"
En este caso, todos los objetos del tipo party animal van a tener esa variable X. Sí, que la voy a inicializar en cero. Es un tienen un campo que lo inicializo en cero. Y después van a tener un código, un poco de código, un método, una función. Esa función dice party. Y acá hay una un parámetro que reciben. Reciben un parámetro de sí mismo.
Y acá por lo que veo es toma el valor de x y le suma uno y le va armando un contador. Cada vez que yo llamo a esta función incrementa en uno esta variable. Sí, con esto que tengo acá arriba, esta parte que está acá es la definición de la clase. ¿Sí? 

Ahora, esto que tengo acá, estoy construyendo un objeto, la estoy instanciando, estoy diciendo que esta variable va a ser un objeto de esta clase. Sí, acá estoy usando el constructor, decimos, de la clase.

Estoy llamando, así como llamábamos a una función acá, estoy llamando a la clase. Entonces, a partir de ahora, este AN es un objeto, es una instancia de esta clase que internamente tiene un campo y tiene una función. Y como la tiene internamente esa función, yo la voy a poder ir usando varias veces. ¿Sí? 

Entonces, esta parte que estoy haciendo acá, le estoy diciendo, "Bueno, a esta instancia de este objeto, lo que quiero es que ejecutes el método party." Entonces, va a ejecutar la función party.

				PartyAnimal.party(an)

La ejecuto una vez, la ejecuto dos veces, la ejecuto todas las veces que yo necesite, pero esta función, este código va a estar metido dentro del objeto, va a ser parte del objeto. Sí, esto que tengo acá es como decir tengo de la clase party party animal, quiero usar el el la función party y le quiero pasar esta propia instancia, este propio objeto. No quiero otro, quiero este propio.
Sí, ese este propio que le estoy pasando es este 
						self 
que le estamos pasando acá. Sí, esa palabra self es un estándar que se usa para hacer referencia a la misma instancia. Como puedo tener varios objetos de de esta misma clase en memoria, yo le estoy diciendo, quiero que te modifiques, pero vos, no otro, vos mismo.

Sí. Entonces, vamos, ahora lo vamos a ver en código este ejemplo. Sí. Entonces, yo defino una clase, le pongo un atributo, le pongo una función y después la uso, la creo y la uso. ¿Sí? Entonces, para poder ejecutar esto, lo que vamos a hacer es ejecutar el archivo que tienen ahí dentro del repositorio en la clase 11, que se llama pa
rty.p. 
Cuando lo estemos ejecutando la primer línea, todo esto que está acá es la definición de la clase.
 Acá lo que estamos haciendo es generar un espacio en memoria que adentro va a generar un campo que se va a inicializar en cero y va a tener una función ya programada que se llama party. 
¿Qué hace esa función? hace, lo que hace es tomar de sí mismo la variable X y le suma uno y la vuelvo a guardar en sí misma y después aparte me muestra un print.
Entonces, cada vez que yo llame, sí, este self, le estoy diciendo, "Tomá tu propia instancia, ¿sí? Fíjate vos mismo tu campo X." 
Y por eso acá le estoy pasando la instancia y le digo de vos mismo tomá el valor de x y a ese valor sumale uno y guardalo dentro del mismo x.
Entonces, cuando yo lo llame la primera vez, lo que me va a ir mostrando es 1 2 3 y le va a ir sumando uno a esta variable que tengo acá, 
porque lo que le fue haciendo es primero le sumo uno, después le sumo dos, 2 + 1 me va a dar 3. Entonces, por cada vez que yo le estoy sumando, estoy usando la variable distancia que se llama x. 

Sí, vamos a ver esto.
Para ver este ejemplo, me voy a ir al Visual Studio y voy a abrir ese partil animal. ¿Sí? Entonces, fíjense, acá tengo la definición de la clase, le paso el nombre de la clase, genero el atributo de esa clase. Acá tengo un método que lo que le estoy diciendo es recibe por parámetro eh así mismo y le sumo uno y me imprime en pantalla hasta ahora y cada vez que lo llamo me va a devolver eso. Sí, voy a comentar estos dos.
para que veamos eh para que no se ejecuten. Sí. 
Y acá lo que hago es llamo a la clase, genero un objeto. A partir de ahora, ese objeto en la memoria se llama AN y del objeto AN uso el método Party y Party va a recibir su mismo objeto. Sí. Y me va a pasar ese cero. 
Entonces voy a voy a guardar esto y lo voy a ejecutar.
Y fíjense que acá dice hasta ahora uno. 
¿Por qué? Porque lo llamé una sola vez.
 Entonces, a cer0 le sumo uno cuando imprimo x, imprimo de esa misma instancia y primo su valor x, me va a dar 1. 
En cambio, si ahora luego de instanciarlo lo llamo tres veces, voy a salvarlo, voy a volver a ejecutarlo. Vamos a ver qué me dice.
Un, dos, 3, porque por cada vez que le voy haciendo se va guardando en la memoria ese objeto. ¿Sí? ¿Me van siguiendo hasta acá? Sí. Bien. Sí. 

Voy a volver a la presentación. Sí. Entonces, cuando nosotros queremos ver cuál es la funcionalidad que tiene un objeto, qué métodos, qué campos tiene, tenemos el comando DIR, que yo se los había mostrado.¿Sí? 

Ignoremos por ahora todos estos que dicen guion bajo, guion bajo, que los vamos a ver más adelante, ¿sí? 

Pero el resto de las palabras que aparezcan, ¿sí? 
Son los métodos. 

>>> dir (y)
add delattr delslice setitem 		estos están entre _ _
'clear', 'copy', 'count',			de aquí en adelante son métodos
'extend', 'index', 'insert', 'pop',
'remove' , 'reverse', 'sort' ]
>>>

Entonces, tanto DIR como Type me dice qué es lo que tiene ese objeto. 
Si yo ahora me voy, por ejemplo, al código que teníamos acá arriba, eh, que teníamos en el visual, permítame envolver acá.
Aparte de hacer esto, lo voy a hacer acá. Ahora voy a hacer lo siguiente. Voy a hacer un print. ¿Y qué voy a imprimir? Voy a imprimir lo que me devuelva type. Pero el type de ¿qué? De AN, del objeto que acabo de crear. 
Sí, voy a ejecutar de vuelta esto. Y fíjense que me dice esto es de la clase party animal, que es la clase que yo definí. Sí.

PS C:\Users\servi\OneDrive\Desktop\curso> & C:/Users/servi/.pyenv/pyenv-win/versions/3.12.0/python.exe "c:/Users/servi/OneDrive/Desktop/curso/IAPythonPrincipiantes/Clase 11/party.py"
Hasta ahora 1
Hasta ahora 2
Hasta ahora 3
<class '__main__.PartyAnimal'>
PS C:\Users\servi\OneDrive\Desktop\curso> 

Y dice main porque la clase está definida dentro del mismo del mismo archivo. Sí, pero acá me dice que es de la clase partil animal. Ahora, si yo aparte del print este le pongo un print eh dir a an, lo salvo, lo ejecuto de nuevo. 

PS C:\Users\servi\OneDrive\Desktop\curso> & C:/Users/servi/.pyenv/pyenv-win/versions/3.12.0/python.exe "c:/Users/servi/OneDrive/Desktop/curso/IAPythonPrincipiantes/Clase 11/party.py"
Hasta ahora 1
Hasta ahora 2
Hasta ahora 3
<class '__main__.PartyAnimal'>
['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getstate__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'party', 'x']
PS C:\Users\servi\OneDrive\Desktop\curso>

Fíjense que me está diciendo todos los que tienen variables bajas, que le dije, bueno, vamos a dejarlo por ahora, pero me dice, tengo un party y tengo un X.
Quiere decir que yo puedo hacer referencia a el objeto punto party y también puedo hacer referencia al objeto punto X. ¿Sí? 

Entonces, puedo ver el valor y puedo llamar al método. Puedo ver un campo, un atributo o puedo usar la función. Sí, fíjense que me aparece acá. 

-Entonces nosotros podemos usar dir y type objetos, para ver cómo están compuestos, para ver qué funcionalidades tienen.-
1.57.03
¿Sí? Entonces acá está justamente el ejemplo que acabamos de hacer, el type y el DI de este objeto party, ¿sí?, que nosotros acabamos de generar, del parting animal. 

Ahora, esto del partil animal nosotros lo podemos eh usar para distintas cosas. Cuando nosotros estamos creando, instanciando un objeto, a partir de ese momento el objeto empieza a estar vivo en memoria.

¿Sí? Y como yo les decía, los objetos se crean y cuando ya no lo usamos más, se borran de la memoria.

 Por lo tanto, hay dos métodos que por ser objeto todos los objetos tienen.

 	-Dos métodos que son el constructor y el destructor. ¿Sí?

 Cada vez que nosotros instanciamos un objeto, estamos llamando al constructor 
y cada vez que nosotros terminamos la ejecución de ese programa se llama al destructor.

¿Para qué? para eliminarlo y limpiarlo de la memoria, porque si no todas esas variables quedarían todo el tiempo en la memoria. Sí, 

Python tiene ese recolector de memoria que lo que hace es cada vez que terminamos de ejecutar algo, todos los objetos que se crearon con el destructor se borran de esa memoria.

¿Sí? Entonces, los constructores lo vamos a usar mucho y son esas instancias que eh poníamos entre paréntesis el nombre de de la clase.
 Ese es el constructor 
y el destructor se usa solo y muy rara vez cuando necesitemos algo muy específico. ¿Sí? 

Entonces, ¿cuál es el propósito principal del constructor? 
Bueno, a veces necesitamos instanciar una clase, pero que tenga ciertas eh ciertos valores preestablecidos.

Yo quiero que se genere un objeto del tipo perro, pero que ya tenga una configuración. ¿Sí?

 Entonces, yo puedo armar y modificar ese constructor. Sí. 

Y también puedo armar ese destructor, tanto el constructor como el destructor. En Python se usa esto, 

			CONSTRUCTOR Y DESTRUCTOR
El propósito principal del constructor es configurar algunas variables de instancia tengan los valores iniciales adecuados cuando se crea el objeto
class PartyAnimal:
x = 0
def __init__(self): 				ESTE ES EL CONSTRUCTOR
	print("Estoy construido")
def party (self):
	self.x= self.x + 1 
	print('Hasta ahora', self.x)
def _del_(self):					ESTE ES EL DESTRUCTOR
	print("Estoy destruido", self.x)
an PartyAnimal ()
an.party()
an.party()
an 42
print("an contiene", an)


 Este es el constructor y este es el destructor.
¿Sí? Cuando yo instancio el objeto se está llamando al constructor. 
Entonces, todo lo que está dentro del constructor se va a ejecutar.
 Cuando yo borro un objeto, lo que se vaya lo que se llama es al destructor. ¿Sí? Entonces, yo les dejé un party dos, que es lo que es para que podamos verlo en ejecución. Sí.
Si yo ejecuto ese parte dos, se los dejé ahí eh dentro de repositorio. 
Voy a cerrar este, este y esto. 
Y voy a abrir este party 2. Sí,
 fíjense en acá está eh la función que vamos a usar y acá al constructor por defecto que existe no tiene código, pero yo lo que estoy haciendo es sobrescribiéndolo, le estoy agregando funcionalidad, le estoy diciendo que imprima, estoy construido, ¿sí? 
Y al destructor que es gu bajo del le estoy diciendo estoy destruido y que me imprima cuál es el valor de x. Sí. 
Como nosotros eh el destructor solo se va a llamar al momento de cerrar el programa, 
voy a forzar a que se destruya el objeto. 
¿Cómo lo voy a forzar? Cambiándole y pisándole el valor. ¿Sí? 
Entonces, acá le estoy diciendo an, estoy llamando al constructor party animal. Cuando yo pongo partir animal, le estoy llamando a esto. Entonces se llama, se crea la instancia y se va a llamar a este constructor.
Después uso partí uno dos veces y acá la variable la piso con un 42. 

Cuando la estoy pisando con un 42, lo estoy cambiando a esa clase, esa variable ya no es más del tipo party,
 ahora es del tipo entero, 
entonces la estoy destruyendo. 

En ese caso se va a llamar al destructor. Y después acá abajo lo que voy a hacer es cargar en memoria.

Sí, voy a a ver qué quedó en la memoria, qué contiene esa variable. Para poder seguir esto paso a paso, vamos a usar esto del 

					debug 

que habíamos hecho la otra vez. Sí. Entonces, voy a pararme acá, voy a dejar eso ahí, lo voy a poner en ejecutar para que lo veamos una vez ejecutándose. 
Dejo el punto rojo en la línea
an = PartyAnimal()

Y fíjense que dice, 

Estoy construido
Hasta ahora 1
Hasta ahora 2
Estoy destruido 2
an contiene 42
PS C:\Users\servi\OneDrive\Desktop\curso> 

"Estoy construido hasta ahora uno, hasta ahora dos. Cuando se pisó dice estoy destruido." Y después al final, como lo pisé, me está diciendo ahora que el valor ya no es una clase, sino que es el 42. Sí. Si esto lo hacemos en modo de debag, es de que habíamos visto en algún momento que podíamos debaguear paso a paso. Vamos a venir acá, vamos a ejecutar en modo de bag para poder ir viéndolo.
Ahí se está llamando, se va a ir ejecutando y cuando llegue acá se va a pisar. Sí, ahí está. Ahí llegó. Ahí se paró. Si yo me fijo ahora, no tengo variables, no hay nada cargado, cuando ejecute esta línea, lo que va a hacer es llamar al constructor. Fíjense que se ejecutó el constructor. Sí. Entonces, acá dice estoy construido.
Y fíjense que me imprimió, estoy construido, se creó en memoria. Ahora sí. se ejecutó es estoy construido y si hago un pasito más, fíjense que ahora en memoria me va a parecer que tengo un objeto acá, tengo un an que es del tipo party animal y que adentro tiene todos los métodos y uno de ellos va a ser el party. A ver si puedo hacer lo que vaya más para abajo para que entre todo.
Vamos achicar un cachito de la letra. Ahí está. Sí. Acá tengo la variable que ahora está en cero. Sí. Y tengo el método party. Acá está. Tengo la variable en cero y el método en party. Lo ejecuto una vez. se va a ir a la función. Acá la llamé. Entonces va a la función, se suma.
Entonces ahora x, si yo me fijo acá, ahora x vale 1, por lo tanto imprime el valor de x. Acá me va a decir que vale uno. Hasta ahora uno. Listo, se ejecutó esta línea. En la segunda línea lo vuelvo a llamar, vuelve a ir a la función. Ahora ax que vale 1, sí le va a sumar uno más. Entonces ahora x vale 2. Por eso cuando ejecute la línea esta va a imprimir. Ahora vale dos.
Hago uno más y acá este objeto que es de la clase party animal, ahora lo voy a pisar y lo voy a destruir poniéndole otro valor, por lo tanto se va a llamar al destructor. Ahí que lo acabo de pisar, me va a decir que ahora está destruido y que an contiene dos. 42. Estoy destruido. Sí. y se destruyó con el valor de dos.
La última vez que este objeto en memoria funcionaba tenía un dos. ¿Sí? Entonces acá vemos el concepto de instancia. Tengo una funcionalidad que viene dada por la función party, su constructor, su destructor. Tengo unos campos. Sí. Y acá lo que hice fue cada vez que aparecía un animal le sumaba uno. Sí, 
es es un ejemplo tonto, pero para que vean cómo funciona. 

Voy a volver a la presentación. Sí, eso fue lo que lo que ejecutamos recién.
Estoy destruido. Sí. Entonces, tanto el constructor como el como el destructor son opcionales. 

El constructor 

def __init__(self): 				ESTE ES EL CONSTRUCTOR

se va a utilizar normalmente cuando queramos configurar alguna variable, cuando queramos que se cree el objeto con algún valor puntual. Sí. 

Y el destructor

def _del_(self):					ESTE ES EL DESTRUCTOR

 lo van a usar muy rara vez cuando necesiten alguna funcionalidad muy específica.

Ahora, y con esto vamos a cerrar la clase de hoy. Puedo tener muchas instancias de un objeto de la misma clase. ¿Sí? Entonces, en la programación orientado a objetos, el constructor de una clase es ese bloque especial que lo vamos a llamar cada vez que yo cree un objeto.
Pero yo puedo crear muchos objetos de esa clase, ¿sí? Y cada objeto se va a almacenar en la memoria con su propio nombre de variable y vamos a poder llamar a cada objeto por esa variable. Y son todos de la misma clase, pero cada uno va a tener sus propios valores, como vimos los casos de los perros, ¿no? Y cada instancia va a tener su propia variable de distancia y cada instancia va a tener sus propios métodos.

MUCHAS INSTANCIAS
En programación orientada a objetos, un constructor en una clase es un bloque especial de sentencias llamadas cuando se crea un objeto.
Podemos crear muchos objetos: la clase es la plantilla para el objeto
Podemos almacenar cada objeto disinto en su propia variable
Llamamos a esto tener varias instancias de la misma clase.
Cada instancia tiene su propia copia de las variables de instancia

class PartyAnimal:
   x = 0
   name = ""
   def __init__(self, z):
     self.name = z
     print(self.name,"construido")

   def party(self) :
     self.x = self.x + 1
     print(self.name,"recuento",self.x)

s = PartyAnimal("OMAR")
j = PartyAnimal("JUAN")
s.party()
j.party()
s.party()

Entonces, yo puedo crearme, acá vemos un código donde estoy generándome dos contadores, ¿sí? y le estoy poniendo x = 0		 name, 
le estoy poniendo un vacío en el constructor. Lo que estoy haciendo acá es definir que el nombre sea igual al nombre de que le estoy pasando por parámetro. Entonces, le paso la instancia y la variable Z. Como acá le estoy pasando esa variable, eso es lo que le estoy pasando acá.
Entonces, acá le estoy pasando el nombre y se le va a asignar cuando se construye. Le va a asignar un nombre y va a decir se construyó tal. Y esto del contador va a decir, bueno, voy a usar de este objeto su nombre y voy a decir cuánto tiene la variable X. Recuento.
Y acá estoy generando dos instancias distintas, una que es la S y otra que es la J. Entonces, ¿qué hace este código? Voy a tener en los constructores y cada constructor sí va a instanciar uno con el nombre Omar, otro con el nombre Juan y cada uno va a tener su propia variable. Por lo tanto, si yo ahora ejecuto el Python instancias, vamos a ver qué dice esto.

OMAR construido
JUAN construido
OMAR recuento 1
JUAN recuento 1
OMAR recuento 2
PS C:\Users\servi\OneDrive\Desktop\curso>

Osmar construido, Juan construido, recuento uno, recuento uno, recuento dos. Sí. Entonces, vamos a ir al código para ver puntualmente este caso. ¿Sí? ¿Qué va a pasar cuando estoy acá? Estoy llamando al a la clase y le paso unos parámetros, en este caso un nombre. Entonces, ¿esto qué hace? me crea en memoria un S y ese S va a tener una x = 0, porque se lo estoy inicializando acá, y un nombre que en principio se crea vacío, pero cuando se construye eso que recibe, que lo tengo acá, se le asigna al campo name. Por eso el constructor lo que hace es instanciar ese objeto ya inicializado.
 Esta segunda línea va a ser lo mismo, pero en este caso me va a generar un J que también va a tener, va a recibir el nombre Juan. Juan va a pasar por el constructor y se lo va a instanciar al campo name, por eso me aparece acá. Y el cero va a quedar en cero. Perfecto. Entonces, ahora tengo dos instancias distintas.
Acá acabo de instanciar dos objetos de la misma clase, pero cada uno tiene su nombre y cada uno tiene su X. Acá llamo al party, pero del primer objeto, por lo tanto, la primera vez me va a decir recuento uno. Entonces este valor va a valer uno. Acá estoy llamando al J, por eso acá me dice Juan recuento uno.
Estoy cambiando este valor a uno y acá vuelvo a llamar a a la instancia S, a la primera instancia y como ya tenía uno, por eso acá me va a decir dos. Sí, vamos. Les voy a mostrar esto en el código. Voy a cerrar este. Y esto lo tenemos acá en instancias. Sí. Voy a cerrar las terminales y lo voy a ejecutar una vez para que veamos.

Sí, es exactamente el mismo código que les mostré en la presentación, solo que ya lo tienen acá para que no tengan que estar escribiéndolo. ¿Sí? 

Entonces, le paso, le digo, "Toma tu instancia y al parámetro que estás recibiendo, guardalo el nombre." Entonces, si yo ahora lo ejecuto, ¿sí? 

Fíjense que cuando instancié la primera vez, cuando se ejecuta esta línea, me dice Omar construido. Cuando le ejecuté la segunda línea, me dice Juan construido.

Sí, lo voy a poner acá al punto rojo del debug 

s = PartyAnimal("OMAR")

y lo vamos a hacer un debba. 

Y con esto vamos redondeando. Si hay alguna duda, alguna pregunta, la pueden ir haciendo. 

Sí, mientras puedo ahora eh si yo vuelvo a hacer eh por ejemplo con otra variable eh m igual a parte animal y entre paréntesis le envío eh Omar de nuevo con otra variable, ¿cómo la va a contemplar cuando se ponga? otro objeto distinto que tiene el mismo el mismo campo, ¿okay? Que justamente tiene el mismo valor, pero es un objeto distinto porque vos le estás poniendo un y y party lo va a tomar como uno, como otro otro vas a tener tres. Justo
coincide que se repita el nombre, pero no no no es que si es distinto, es igual porque tiene el mismo nombre, es un objeto distinto. ¿Por qué es distinto? Porque acá le estoy poniendo un m, le estoy instanciando en memoria otro objeto que coincide en los valores del nombre.
Se llaman igual, tienen el campo nombre, contienen el mismo valor, pero son objetos distintos. Sí, sí. Okay, entiendo. Bien, entonces en este caso vamos a ver justamente voy a ejecutar esta línea. Llama al constructor. En este caso, fíjense que Z está recibiendo el Omar. Se lo va a asignar. Entonces, fíjense que Z ahora vale Omar. Sí, ahí dice Omar construido. ¿Por qué? Porque ya usó el constructor.
Ahora cuando me vaya a construir el segundo, recibe Z, recibe Juan, se lo asigna al campo name y me va a decir Juan construido. Bien, ahora cuando yo esté llamando, llamo de manera intercalada, ¿no? Entonces va a haber uno que lo voy a llamar dos veces y uno que lo voy a llamar una. llamo al primero. Ese era Omar. Entonces me va a mostrar cuando llegue a esa parte. Sí, tengo las dos instancias.
¿Ves que están en memoria? Están en posiciones distintas. Entonces son instancias distintas. Si tengo un tercero y le paso Omar por nombre, van a ser tres instancias distintas, solo que hay dos que tienen en ese campo el mismo valor. Sí, lo que los hace diferente es que están en otro lugar de la memoria.
¿Sí? Entonces ahí me va a decir el primer recuento uno, Juan recuento dos y cuando llame de nuevo al al que tenía como nombre mar, como ahí adentro este ya tenía un uno, cuando le incremente uno más me va a decir dos. Sí, ahí le puso el dos. Entonces ahora cuando imprima me va a decir Omar 2. Termina y se va a llamar a todos los destructores, que yo ahora acá no lo tengo, pero se va a llamar a todos los destructores y se destruye. Sí, como no como no lo definí, no no estoy viendo nada, pero se llamó y se borraron todos
esos objetos de memoria. ¿Sí? Entonces cada una de estas variables son objetos distintos que los tengo en memoria. Sí. Y cada uno va a tener sus campos y cada uno va a tener sus funciones. Después vamos a ver cómo podemos utilizar esta idea del objeto para usar sistemas, para armar programas, pero quería que prueben y vean primero esto.
¿Sí? Entonces, usando el editor, les dejo como desafío, como tarea, que tomen este código, ¿sí?, que dice desafío uno y traten de transformar esto que es eh código eh secuencial donde definíamos una función, otra función y acá la usábamos. Traten de convertir esto a clases que tengan una clase triángulo, una clase rectángulo y que cada una tenga el método calcular área.
Sí, como tarea. Y después, desafío dos, este código tiene un error. Sí, traten de identificar cuál es ese error y de corregirlo. Sí, todo esto se los estoy dejando en el repositorio. Acá dentro tienen desafío uno. Sí, acá les dejo el código para que tomen como base.
Y lo que tienen que hacer es esto que es programación estructurada a programación orientada por objetos. Transformar este código en un conjunto de clases, triángulo y rectángulo. Cada una de esas clases tiene que tener el método de calcular el área. ¿Sí? Entonces, acá tienen la función, acá tienen algunas variables. Lo que quiero es que lo transformen a clases, ¿sí? Y que después puedan instanciar una un triángulo, que puedan instanciar un un cuadrado, un rectángulo, ¿sí? Y puedan hacer el uso de las de esas clases.
La clase que viene vamos a ustedes me van a a mostrar qué es lo que hicieron y si quieren compartirlo en la semana por WhatsApp lo pueden hacer. Sí. Y vamos a arrancar viendo esos ejemplos y cómo lo podríamos haber resuelto. Y el desafío dos, acá hay algunos errores, ¿sí? ¿Cómo es? A ver si se dan cuenta cuál es el problema y por qué está marcando esos errores.
¿Sí? Hasta acá la clase de hoy. La idea es tener esta pequeña introducción sobre objetos. Vamos a avanzar mucho más y a ponerlos en práctica a partir de la clase que viene. ¿Sí? ¿Dudas, preguntas? Por ahora no. Mañana cuando empecemos a hacer ejercicios veremos. Perfecto. Bueno, perdón que me haya extendido un poquito, pero no quería atrasarme mucho más y tampoco como son temas importantes, me parece que el tiempo de consulta también hay que hay que tenerlo. Así que les dejo esas dos tareas, traten de resolverlas y la clase
que viene vamos a retomar a partir de este punto, ¿sí? Así que bueno, fin de semana y nos vemos la la semana que viene. Sí, buen fin de semana. Apenas esté la grabación les aviso como siempre para que la tengan ahí disponible. la practiquen y tienen esos dos ejercicios, así que tienen tarea. Nos vemos la semana que viene.
Gracias que viene. Hasta luego. Gracias.

















































