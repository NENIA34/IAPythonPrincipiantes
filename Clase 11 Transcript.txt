Clase 11 Transcript

01 Usando GIT

02 ¿Que es POO?

03 Terminología y Clases en Python

04 Ciclo de vida de un Objeto

Bueno, bienvenidos a todos a esta nueva clase, ¿sí?, del curso Formate como ingeniero NIA, comenzando con Python, ¿sí? que para hacer un nombre más corto le pusimos I a Python para principiantes. Ya estamos por la clase número 11 y según el orden de las clases y el programa que teníamos pautado, hoy nos toca hablar sobre programación orientada a objetos.
¿Sí? Pero antes de arrancar con eh programación orientada a objetos, me gustaría que de a poquito vamos a ir incorporando los conceptos que eh vimos hacia el final de la clase pasada, que eran los conceptos de el repositorio de Git, de empezar a trabajar con Git. ¿Sí? Entonces, hoy voy a cambiar un poquito la la modalidad de cómo les comparto los archivos que vamos a usar y eh voy a empezar a partir de esta clase en vez de subirlo al Drive.
en el Drive van a tener la presentación, pero voy a empezar a subir los códigos que hagamos en Python y las cosas que vayamos haciendo las voy a subir a un repositorio. ¿Sí? Ahora después en breve los voy a pasar ese repositorio para que podamos ir eh trabajándolo y que ustedes puedan ir sincronizando y o haciéndose un fork. Después vamos a ver qué es eso.
Eh, para que puedan ir eh adquiriendo de a poquito la la habilidad de trabajar con los repositorios. ¿Sí? Entonces, eh es una manera de ir forzándolos a que vayan incorporando nuevas eh nuevas tecnologías o nuevas formas de trabajar. Sí, vamos a ir viendo si si resulta, si no resulta. Eh, la idea es que se vayan familiarizando con el manejo de repositorios.
¿Sí? Entonces, hoy en esta primera clase vamos a tratar de usar Git, con lo cual vamos a instalar Git y vamos a hacer unos primeros pasos. Voy a tratar de hacer ese ejercicio que les había dejado pendientes para que ustedes puedan ir adquiriendo el conocimiento.
No sé si vamos a hacer la totalidad de los comandos, pero sí los más importantes y que creo que a ustedes por ahí les va a servir. Durante el resto del curso vamos a seguir eh utilizándolo y después sí vamos a ir ya a lo que es la programación orientada a objetos. Vamos a hablar un poquito de lo que es eh toda la terminología, qué es una clase, qué es un objeto, qué es una instancia.
Eh, vamos a ver cómo se arma una clase en en Python, ¿sí? ¿Qué clases ya tenemos en Python eh establecidas? Y eh espero que nos dé el tiempo poder ver lo que es el ciclo de vida de un objeto, ¿sí? ¿Cuánto tiempo dura o vive un objeto, cuándo se destruye, cuándo se crea? ¿Qué cosas pasan cuando trabajamos con objetos? Ese va a ser el objetivo de esta clase para que tengan la base de lo que es la programación orientada a objetos que después a posteriori vamos a ir viendo conceptos, ¿sí? Conceptos de herencia, de polimorfismo, de encapsulamiento,
que eso nos va a servir para cuando empecemos a trabajar con frameworks, ¿sí? con frameworks de eh de Python, por ejemplo, para hacer desarrollo web, para conectarnos a una base de datos, para hacer eh uso de alguna librería para desarrollos de aplicaciones de escritorio.
Es decir, cuando empecemos a trabajar con eh con librerías, el concepto de objeto va a estar muy presente. Sí, hoy estuvimos eh hoy digo hoy, ¿no? En las clases anteriores ya estuvimos trabajando con objetos, pero por ahí sin nombrarlos como tal. Sí. Entonces, vamos a ir haciendo también una pequeña introducción a todo eso, ¿sí? Entonces, bueno, para arrancar vamos a tratar de de ir incorporando Gitimos aprendiendo, ¿sí? Por eso, como les decía, vamos a empezar a trabajar con Git, ¿sí? Pero antes de eso quiero que hagamos la introducción. Yo les había dejado como tarea que vayan investigando
que era Git, ¿sí? y les dije que había unos comandos básicos y que Git era una herramienta que cualquier desarrollador necesitaba aprender. Sí. Y eso nos permitía también ir controlando las versiones que teníamos de nuestro código y cómo va evolucionando un proyecto o cuando tenemos que trabajar de manera colaborativa también poder ir compartiendo con otras personas y siempre manteniendo el historial de los cambios que se van haciendo.
Entonces vamos a empezar a familiarizarnos un poquito más en la práctica con todos estos conceptos. Para eso yo les había dado como un cuestionario que íbamos a trabajar con eh algún modelo de lenguaje. Yo en este caso voy a usar eh chat GPT, ¿sí?, para poder trabajar estas instancias de eh de Git, ¿sí? Entonces, lo primero que le vamos a preguntar es cómo instalar y cómo hacer una configuración inicial de Git.
Sí, para eso, eh, para poder emular todo eso, como yo ya lo tengo instalado en mi máquina, voy a hacer correr todo en una máquina virtual. Sí, ustedes es puede ser la máquina de ustedes, no hay ninguna necesidad. Si ya lo tienen, no pasa nada. Y si no, lo vamos a instalar juntos.
¿Sí? Entonces, lo que vamos a hacer ahora es primero preguntarle cómo instalar Git, ¿sí? Para poder tenerlo disponible dentro de nuestro eh entorno de trabajo. ¿Sí? Entonces, voy a ir a la máquina virtual. Primero voy a ir al al a chat GPT. Denme un segundito. Y también vamos a usar esa máquina virtual que les estaba eh comentando. Sí. Entonces, voy a ir a la máquina. Ahí estoy dentro de la máquina virtual.
Si yo voy acá al al buscador, voy a poner git. Vamos a ver que no tengo no tengo ningún eh me dice que hay una coincidencia, pero es una coincidencia en la web. Sí, evidentemente no tengo no tengo instalado Git. Para verificarlo puedo ir a la a a la terminal. Entonces, me voy a abrir una terminal del sistema simplemente para validar de que no lo tengo instalado.
Sí, si yo ahora escribo git guion version, vamos a ver que dice que Git no se reconoce, con lo cual en esta máquina virtual, en este entorno, no tengo Git instalado. Sí. Entonces, para poder hacer uso de Git, necesitamos tenerlo instalado. Entonces, vamos a ir a rápidamente a Chat GPT. Acá tengo una ventanita con la cuenta de chat GPT y lo primero que le vamos a instalar es cómo instalo Git en mi máquina.
Sí. y ahí me va a decir cuál es la dirección para poder ir bajando. En este caso, nosotros como vamos a trabajar con eh con Windows, ¿sí? La mayoría de nosotros esta dirección que nos está dando acá es justamente la que eh necesitamos. Sí. Y me dice que una vez que termine de de instalarlo, tengo que verificar con git version, que es justamente el comando que acabo de tirar yo para ver si esto funciona. Sí.
Entonces, acá me está diciendo para para Windows, para Mac y para Linux. Sí. Entonces, yo lo que quiero es que nos acostumbremos no solamente a a trabajar con código y aprender Python, sino que también usemos la inteligencia artificial y las herramientas que tenemos para aprender. Por eso les había dado como tarea hacerle estas preguntas a un modelo del lenguaje.
Entonces, ahora vamos a ir justamente a esa dirección, pero lo voy a hacer, la voy a copiar. Se las voy a pasar por el Zoom. Sí, la mayoría debe tener Windows. Si alguno tiene otro sistema operativo, me me dice y lo y lo vemos. y voy a ir directamente a la a la terminal, ¿no? Entonces, en la terminal, en la terminal, en la máquina en la que yo quiero instalarlo, voy a dejar esto minimizado ahora por un ratito.
Me voy a abrir el navegador y voy a ir a esa dirección. Sí, en este caso voy a pegar la dirección de git. Download Win. Esto debería empezar a bajarme el instalador. Vamos a ver que tenemos eh distintas versiones. La mayoría van a tener procesadores que son de X64. Sí. Entonces vamos a a elegir ese esa opción. Está la opción portable, que esto es para llevarlo de un lado a otro, pero yo les recomiendo instalen directamente esta que que tienen acá. Entonces voy a a bajar ese archivito.
Ese archivito se va a bajar. Una vez que termine de de bajarlo en el navegador, vamos a ir actualizando y vamos a hacer la instalación. Ahí está. se va a abrir y como todo instalación de Windows, hay que ir dándole siguiente, siguiente. Vamos a esperar un ratito que abra. Está tardando en abrir. Ahí va una preguntita.
Omar, a mí me salió fatal error e cuando yo puse en el CND si tenía GIB. Eh, debe ser que no está el comando ejecutado, que que no está instalado. Sí, por eso hay que instalarlo instalarlo Sí, sí, sí. Igual si ya está instalado y lo y lo lo instalas encima, no va a pasar nada porque a lo sumo se actualiza la versión. Sí.
Entonces, bueno, ahí vemos que le dice doble clic a ese archivito de ejecutar. Entonces, ahora le voy a dar que sí, que lo quiero ejecutar. Van a aparecer. Bueno, acá como le di varias veces, me lo está abriendo varias veces. Ahí está. Ahí me va a decir la licencia. Voy a aceptar la licencia. Le voy a decir que sí. Me va a decir a dónde se va a instalar. Le vamos a dar continuar.
Eh, acá le podemos agregar los los iconitos y si queremos que se use el B y todo lo que queremos, yo les diría si no quieren que se agregue el lo único que agregaría por ahí si alguno quiere tenerlo es el icono en el escritorio, pero con los que viene por defecto les va a alcanzar. Vamos a hacer siguiente siguiente. Dejamos todo tal cual está por defecto.
Open SSH. Eso es porque necesitamos hacer conexiones seguras cuando hagamos conexiones a a repositorios remotos. Entonces, acá estamos instalando todas las librerías necesarias para poder usar Git e el estilo en la terminal de cómo se usa, de cómo se convierten los archivos, de cómo se controla. Sí, está todo preconfigurado.
Entonces, en Windows es a darle siguiente siguiente a todas estas terminales y todo esto que vemos acá. Sí. Entonces vamos a esperar que termine de instalarse. Una vez que esto termine de instalarse, yo les había dejado una preguntita más, que era, ¿cómo hacemos la configuración inicial? Entonces, le vamos a preguntar a al modelo del lenguaje esto de la configuración inicial.
Sí, mientras esto se va instalando, voy a esperar a a que termine. Me voy a ir a a Chat GPT y le voy a decir lo siguiente. Ya lo tengo instalado. ¿Qué configuración inicial? necesito hacer. Y acá me da algunas ideas que esto está pensado para que yo deje asociado a cada repositorio que yo cree que quede asociado al nombre de mi persona o de mi usuario.
¿Sí? Entonces, no es obligatorio hacerlo, pero esto lo que va a facilitar es no tener que estar cargando todo esto todo el tiempo. Entonces, en el sistema ya va a cargar mi nombre de usuario y mi email. Entonces, cada vez que yo haga un repositorio, una colaboración con alguien, decir que el que colaboró fui yo con mi nombre y apellido y mi email para un contacto. Sí.
Tanto los commit que yo haga como los commit que haga para mí, ¿no? Como los commit que haga para eh otra persona a otro repositorio. Sí. Y bueno, y acá me va a dar varias opciones, ¿sí? Pero bueno, estos son eh como ven acá son opcionales. Entonces, lo primero, lo que por ahí nosotros podemos hacer si es que queremos que figure todo esto para no tener que estar trabajándolo todo el tiempo es hacer estos comandos.
¿Sí? Entonces, me voy a volver a ir a la a la terminal en la en la máquina que estábamos eh trabajando para ver si ya terminó de instalarse. Ahí me está diciendo que sí. Si quiero ejecutar eh Gitbash, Gitbash lo que me va a abrir es una terminal con con colores, ¿sí?, eh de Git, diciéndome en qué rama estoy y qué cosas estoy haciendo.
Así que es como una terminal exactamente igual que la de la de Windows. ¿Sí? Entonces, ahora voy a a volver a abrir la terminal que teníamos abierta. Y si yo ahora escribo git version, me dice que no se reconoce. ¿Por qué? Porque esta terminal yo la abrí antes de tener todo esto instalado.
¿Sí? Entonces, lo que vamos a hacer ahora es ahora que tengo Git, vamos a hacer un cmd. Voy a abrir ahora el símbolo de sistema. Como este sistema ahora yo ya lo abrí con el entorno abierto, debería darme git. Gion version. Ahora sí debería reconocerme que tengo la versión 2.5 de Windows. Sí, ahora que ya tengo instalado Git, voy a poder empezar a hacer uso de esos comandos.
Uno de los comandos que me estaba pidiendo, o que me estaba diciendo el modelo de lenguaje chat GPT era Git Config. Git conf global username. Eso es para que de ahora en más todos los repositorios que yo genere o todos los comits que yo genere lleven mi nombre. Entonces acá tengo que dejar un espacio. Dejo un espacio y escribo mi nombre.
Enter. Listo. Ahí ya quedó registrado de manera global que todos los repositorios que yo genere en esta máquina salgan con el nombreito. Sí, user. Name va a ser Omarfacito. El otro comando que podemos llegar a a poner también como configuración es el de darle un mail de referencia.
Entonces, el objeto user y acá ya estamos hablando de objetos. Vamos a ir adelantándonos un poquito a a lo que estamos trabajando. También tiene la opción de ponerle cuál es el email. Sí, ahí les estoy pasando el comando también por el chat. Simplemente lo que tenemos que hacer es escribir git config global user email. Y acá le ponerle un mail.
Todo esto es para que se genere, cuando se genera la documentación de un repositorio aparezca quién fue que lo hizo. Sí, solamente eso. Yo acá voy a poner mi email yahoo.com.ar. Le voy a dar un enter y lo que nos decía el LM, si lo vamos a a verificar ahora qué otros comandos se podían llegar a usar en la configuración inicial.
Sí, ya hicimos uso del git global, del git user para poder verificar que todo lo que se ha configurado podemos hacer un git confit list, nos dice. Después hay más comandos, ¿sí? Como un editor o eh otros comandos que tenemos ahí. Esos los vamos a dejar, se los dejo por si quieren investigarlo, pero los principales son estos dos de configuración.
Con configion list cuál es la configuración de Git de manera global dentro de nuestro sistema. Entonces vamos a ir a la a la terminal nuevamente. Previamente me voy a a copiar ese ese comando y se los voy a pasar para que lo puedan ejecutar también. Se los voy a pasar por el Zoom. Bien, entonces en la terminal, si nosotros ahora escribimos git confit list, deberíamos ver la configuración de nuestro git.
¿Sí? Entonces, acá vemos que tenemos distintos parámetros, no todos, no todos nosotros lo estuvimos tocando, pero sí tenemos el username y tenemos el user email, ¿sí? Es decir, que a partir de ahora ya tenemos kit disponibles en nuestra máquina. Sí. Em, voy a volver a a la presentación para que podamos eh seguir viendo cuáles eran las preguntas, ¿no?, que veníamos eh trabajando.
En la presentación yo les había dicho cómo instalar, ya lo estuvimos viendo, cómo hacer la configuración eh inicial y ahora cómo inicializar un repositorio y cómo clonar. El cómo clonar lo vamos a dejar para el final. porque después vamos a trabajarlo eh con los códigos que necesitamos para eh ver la parte de programación orientada a objetos. ¿Sí? Entonces, ¿cómo inicializar un repositorio? Eso es lo que lo vamos a preguntar ahora.
¿Sí? Entonces, voy a ir de nuevo a eh al LLM, en este caso a a la IA de Chat GPT y le vamos a preguntar cómo inicializo un repositorio. Para inicializar un repositorio hay que ir a la carpeta que vos quieras eh generar dentro de una terminal y usar el comando git init. Git init lo que hace es armar una base de datos.
Sí, armar una base de datos para poder trabajar, ¿sí? para que nos quede de una manera un poquito más gráfica todos los comandos que que podemos ir usando como git ad, git init, sí, voy a ir haciendo estos pasos. Vamos a ir trabajando con un gráfico que yo les había dado. ¿Sí? Entonces, lo primero que que quiero hacer más allá de seguir la la presentación con todas las preguntas que que veníamos que les veníamos trabajando, quiero avanzar un poquito más y pararme aquí, ¿no? Entonces, lo primero que tenemos que hacer es para inicializar un repositorio. Acá también les dejé
cómo podemos instalarlo. Sí, se los dejé acá abajo. Lo primero que quiero hacer es esto de inicializar un repositorio, decirle, "Bueno, quiero arrancar con Git en este proyecto, en esta carpeta." Sí, para hacer eso voy a generar una carpeta dentro de la máquina. Sí, voy a cerrar esta terminal. Entonces, voy a generar acá y le voy a poner una carpetita y le voy a poner taller. Voy a una nueva carpetita.
La voy a poner taller adentro. Esta carpetita la voy a abrir. No va a tener nada. Sí, no tiene nada, no tiene ningún contenido, pero voy a abrirla en una terminal CMT. Eso me va a abrir una terminal que va a estar parado justo en esa carpeta. Sí, lo que quiero es que vean. A ver si puedo ver acá eh vista. Voy a tildar acá que diga mostrar elementos ocultos. Ahí está.
Y lo que vamos a hacer es un git init. Entonces un git init que es para inicializar una base de datos de control de versiones. Fíjense en lo que va a pasar. Le voy a dar un enter y acá se me generó una carpeta que la vemos con un color más clarito. Sí, no sé si la llegan a ver. Eh, eso es una carpeta oculta.
Dentro de esta carpeta va a haber varios archivos y varias carpetitas. Esos archivos y esas carpetitas son la base de datos de versiones. ¿Sí? Entonces, todo lo que yo cargue y cree dentro de esta de esta carpeta, a partir de ahora, Git va a tener el poder de mirarla y poder hacerle seguimientos. ¿Sí? Entonces, vamos a ir a la a al chat GPT y me dice, bueno, esto creó un subdirectorio llamado Git que contiene todos los archivos internos del repositorio.
Ahora, ¿cómo le agregamos archivos a ese repositorio? En este caso, yo no tengo nada creado. Sí hay un comando que se llama git status, que lo que hace es permitirme ver cuál es el estado de git en este momento en este repositorio. Entonces, si me voy a a la terminal de nuevo, vamos a ver que si yo hago un git status, me va a decir que no hay commits, ¿sí? y que está todo bien, que está todo okay, que estoy parado en la rama master, dice que no hay eh que no hay commit pendientes y que no hay nada pendiente, no hay archivos, no pasa nada, que si yo quiero agregar algún archivo para hacer algún seguimiento, lo que tengo que
hacer es un git. Sí. Sí, Alejandro, sí. Una pregunta, Git quiere decir algo, o sea, es es una una reducción de Este es el nombre de la de la herramienta. Es un control de versiones, se llama así. Okay, pero no no es que G e I significa algo, ¿no? Okay, está bien. Gracias. Bien, entonces, ¿qué va a suceder? que yo ahora, por ejemplo, voy a crear un nuevo archivo, voy a poner nuevo documento de texto, le voy a poner mi archivo punto txt, lo voy a abrir y le voy a escribir y le voy a escribir algo. Sí. Hola a todos.
Voy a agrandar un poquito la letra porque se ve muy chiquito. Lo salvo y lo cierro. Perfecto. Ahora tengo un archivo. Si yo vuelvo a la terminal y hago un git status, me va a decir que detectó que hay un archivo nuevo que no se le está haciendo seguimiento. Es decir, yendo a nuestra presentación, estamos en este estado.
Estamos en trabajando en un archivo, en un directorio, tenemos un repositorio inicializado y eso es lo que estamos hablando cuando hablamos de un directorio de trabajo, una carpeta de trabajo. Y tenemos un nuevo archivo que no se le está haciendo seguimiento. Sí, por eso aparece en rojo. ¿Cómo le hacemos un seguimiento? Poniendo git ad y el nombre del archivo.
Sí, si quisiéramos hacerle seguimiento a todo, ponemos git ad punto y el punto es el equivalente a decirle hacerle seguimiento a todo lo que está dentro de esta carpeta. Entonces vamos a hacer eso. Vamos a decirle que haga un git ad punto, ¿sí? O acá podría poner el nombre del archivo archivo.txt, sí, pero yo le voy a decir que git ad a todo.
Entonces, les voy a hacer un enter y esto va a empezar a buscar qué archivos hay y les los va a marcar como que les está haciendo seguimiento. ¿Sí? De manera todo esto que estamos haciendo por comandos también se puede hacer de manera gráfica, pero me gusta contarle los comandos porque muchas veces cuando estamos trabajando en un servidor o cuando estemos trabajando en otro lado, necesitamos ver todo esto. Sí.
Entonces, si yo hago un git status, vamos a ver que tenemos un nuevo archivo y ahora está en verde. ¿Por qué? Porque a este nuevo archivo ahora sí se le está haciendo seguimiento. ¿Sí? ¿Qué implica que se le esté haciendo seguimiento? que si yo hago algún cambio en este archivo, a partir de ahora va a detectar esos cambios.
Sí, pero para estar más seguros vamos a hacer lo otro que vimos en el gráfico. Una vez que nosotros hicimos un git ad, lo que estamos haciendo es pasarlo al área de staging. El área de staging es un área temporal, es decirle, a todo lo que yo te diga que sí quiero que agregues, tenerlo en esta en esta etapa temporal y detectar cada vez que haya un cambio.
Y cuando detectes esos cambios, me los informás y yo con el git commit te voy a decir, agregaste cambio al repositorio. Entonces eso es lo que vamos a hacer ahora. Detectamos que antes no teníamos un archivo y que ahora lo tenemos y que qué hora quiero que sea parte del repositorio. ¿Sí? Entonces, vamos a hacer un git commit.
Para hacer el git conmit necesitamos darle también un mensaje. Si vamos a lo que nos dice el modelo de lenguaje, sí, ya hicimos el git ad que con el nombre del archivo o git punto que es un comodín que quiere decir todos los archivos. Y ahora lo que nos falta hacer es un git commit, es decir, pasarlo de staging a confirmarlo que lo quiero poner. Ese cambio, ese nuevo archivo quiero que sea parte del repositorio.
Entonces, ahora tengo que hacer un git commit. Sí. Entonces, me voy a copiar esto y por lo general al primer commit le ponemos primer commit. Entonces ahora si yo me voy a a a la terminal, voy a poder hacer un git commit men m y escribirle el texto que quiera que tenga ese primer commit. Perfecto.
Acá me dice hubo un cambio, se insertó un nuevo archivo y se creó ese archivo y se le dio un registro, ¿no? Entonces ahora si hago un git status, vamos a ver que dice perfecto, no hay ningún commit pendiente. ¿Qué implica que no haya ningún eh eh ningún commit pendiente? que en ese en ese visión de staging, en ese estado temporal, no hay nada pendiente de revisión, no hay ningún cambio por informar porque yo ya incorporé esto, salvo que yo le haga un cambio al archivo, ese archivo no se va a modificar, no lo va a detectar.
¿Sí? Entonces, lo que está sucediendo es que del directorio de trabajo de este directorio de trabajo, lo que hicimos fue un git ad que lo controle. Como detectó que era un archivo nuevo, me dijo, "Está pendiente hacer un commit, ¿querés agregarlo?" Y yo le dije que sí.
Entonces, ahora ya lo tengo dentro del repositorio, es decir, dentro de mi repositorio el archivo está con ese estado. ¿Sí? Entonces, estamos ya generando un repositorio, que es una base de datos de todos los cambios que yo fui haciendo dentro de esta carpeta. hasta que yo no agregue ningún archivo o le haga alguna modificación, eso no va a darme sí algún cambio. Vamos a emular eso simplemente yendo el archivo.
Lo voy a a abrir. Sí. Entonces voy a ir al archivo. Como ya me dijo acá que no hay ningún cambio, sí, lo que voy a hacer es abrirlo. Hola a todos, ¿cómo están? Esto es una prueba de git. Voy a salvar. Y a partir de este momento, al modificarse ese archivo, Git se dio cuenta que hicimos un cambio. Como hicimos un cambio y este archivo lo está visualizando, ese cambio paso de a la carpeta temporal, a esta carpetita temporal que estamos teniendo acá, el área de staging. Y yo lo que tengo que hacer ahora es verificarlo. ¿Cómo me doy cuenta de eso?
Bueno, simplemente haciendo uso de esa eh terminal. Sí. Entonces voy a ir a la a la terminal de nuevo y si yo hago un estatus, vamos a ver qué dice. Mira, hay modificaciones en en mi archivo. Sí querés agregarlo, querés eh llevar eso y pasarlo a al repositorio.
Entonces, en ese caso, lo que yo tengo que hacer es decirle, bueno, si quiero agregarlo, si dice, si no querés agregar estos cambios al commit, tenés que hacer un git ad o un git commit y el nombre del archivo. Sí, yo en este caso puedo hacer un git commit, un git commit men- A. El - a lo que implica es que aparte de eh de hacer el comit, quiero agregar ese cambio también. Sí, pero no quiero complicar la vida con todo eso. Sí.
Entonces, vamos a hacer primero un git commit y le voy a decir - m y le voy a decir eh, perdón, antes tengo que hacer el el git commit ad para agregar todos los cambios que haya. Si yo hago un git status, ahora me va a decir, "Está bien, detecté que está modificado y ya lo tengo en el área de stationing, por eso lo veo en verde.
Y ahora sí le hago un segundo commit. Sí. Y fíjense que acá me dice que hubo un archivo, que hubo un cambio, ¿sí? y que hubo eh modificaciones. Todo esto lo estamos haciendo por terminal, por línea de comandos. Sí, les dejo como tarea eh investigarlo con las preguntas que le podemos hacer al modelo de lenguaje que les dejé ahí.
Sí, este repositorio local que yo lo tengo acá ahora así eh trabajando también lo podemos abrir y puede ser un repositorio de código, ¿no?, de de Python. Entonces, lo que vamos a hacer es abrirlo en Visual Studio Code, que ya lo tenemos nosotros, Visual Studio Code instalado. Y al tener Git también instalado, ahora vamos a poder trabajarlo también de manera gráfica, si quisiéramos dentro del Visual Studio.
Entonces, lo que vamos a poder ir trabajando también es con el Visual Studio ir mirando qué fue pasando con todo esto. Entonces, ahora voy a abrir, esperar un ratito, no sé por qué no me abrió, pero ahí el Visual Studio Code. Ahí está un poquito lento. Eh, sí, Alejandro, ¿querías hacer una pregunta? Sí, viene de un rato, de hace un ratito, pero eh cuando vos abriste eso y pusiste hola a todos, ampliaste el tamaño de la letra y no sé si en pusiste Bold inclusive después no te reconoció nada de eso. Le agregué le agregué contenido. Ahora,
ahora lo vemos. Pero no, no te reconoció el cambio que le hiciste a la letra. O sea, vos habías agrandado la letra y después No, agrandé agrandé el el no agrandé la letra en el texto. Lo que agrandé es el notepad para que ustedes lo puedan ver porque se veía muy chiquito. Ah, okay, okay, okay, okay. Está bien, está bien. Listo, listo, listo.
Bueno, entonces tamaño de font y todo eso. Sí, eh, sí, sí, eso es propio de un documento. Está bien. Bueno, entonces acá lo que vamos a ver ahora es que justamente si yo me voy acá a la solita de Git, vamos a ir viendo. Ahora está leyendo el repositorio. Fíjense que acá tengo el historial de todo lo que fue pasando.
Primer commit, segundo commit. Sí. Y acá tengo mi archivito. Si yo abro el archivo, fíjense que dice, "Hola a todos, ¿cómo están? Esto es una prueba de Git." Sí. Ahora yo puedo ver acá con Git, ¿sí? Voy a poder ver por ejemplo qué fue cambiando en cada instancia. Por ejemplo, acá vemos que al principio lo que se hizo fue agregar el archivo y el archivo solamente decía hola a todos, pero que si me voy al segundo vamos a ver que el archivo fue modificado.
Entonces le voy a dar un clic y acá vemos que el archivo dice, ah, a ese archivo que decía hola a todos se le agregó una nueva una nueva línea y acá me la va a mostrar en verde. Sí. Entonces, fíjense en cómo estoy controlando las cosas que fuemos modificando.
Imaginemos ahora que cierro esto, abro el archivo y le voy a decir, le voy a borrar degit. Esto es una prueba de cómo se modifica los archivos y lo salvo. Cuando lo salve, Git se está dando cuenta de que tuvo una modificación y ahí me puse un M de modificado. Sí. Eso, ¿qué quiere decir? que lo tengo, lo estoy visualizando y si yo quisiera lo que tengo que hacer es ese archivo que se detectó los cambios pasarlo, agregarlo al área de stationing, ¿sí? Al área de temporal.
Entonces, lo mismo que hicimos con el comando, ese git ad, lo estamos haciendo acá con este botoncito más, por ejemplo. ¿Sí? Entonces, lo paso al área de station y ahora ya está en el área de stationing, salió de cambios y salió al área de stagion. Como ya lo tengo en el a station, ahora le puedo hacer un commit.
¿Cómo le hago el commit? Con este confirmación de cambios. Y acá en vez de poner menos m el mensaje le voy a poner tercer commit. Tercer cambio, le voy a poner, lo confirmo y a partir de ahora tengo otro punto. Y fíjense que si me fijo acá, cuando me paro acá, pego el historial. Antes esta línea era cómo estás, esto es una prueba de grid.
Y ahora lo que se hizo fue a esta línea se le agregó los espacios y a la vez se agregó esta otra línea. Es decir, yo estoy viendo qué cambios estoy haciendo en cada línea, en cada archivito. Y si quisiera volver en el tiempo, puedo directamente hacer clic en un archivo y abrirlo directamente en ese punto. Sí, yo puedo venir acá y abrirlo y tengo el contenido de ese archivo en ese punto. Sí.
Entonces, esto me permite ir viajando en el tiempo y poder controlar eh qué es lo que estoy haciendo, qué es lo que estoy trabajando. Sí, esa es la intención de que ustedes sepan qué es Git, ¿sí? Que es un control de versiones de cambio. Imaginemos esto con código de Python en vez de texto. Sí, es exactamente igual.
Puedo ver qué cambios subo entre un punto y el otro y cada punto, cada foto, cada commit se le asigna un código. ¿Sí? Entonces, yo puedo ir parándome en cualquier lugar de ese código. Déjenme que busque. A ver, acá Git. Voy a voy a instalar esta extensión que se llama Gitgraph. Le voy a decir que es de mi editor de confianza.
es una es una eh es una extensión que lo que hace es agregarle la poder verlo de manera gráfica también. ¿Sí? Entonces, uno podría ver eh ver esto, me agrega este iconito que lo que me hace es permitir ver de manera gráfica lo mismo que tenemos acá abajo, un poquito más grande.
Entonces, yo puedo venir acá y puedo ver, bueno, en este caso a este archivo se le agregó dos líneas y se le eliminó una, ¿sí? y puedo ver quién fue el autor, cuál es su mail y dónde salió todo esto. Salió de eh la configuración inicial que hicimos. Sí, esto como introducción para que sepan qué es gitar. No me deja pasarlo a staging. Me da un error como si estuviera bloqueado el archivo.
Seguramente ya lo tenés en staging y lo que te falta es el commit. Sí, sí, ahí me di cuenta. Justo me quedó en staging desde el CMD y lo estaba queriendo pasar desde visual y se están está viendo un show ahí, así que gracias. Ahí veo cómo lo arreglo. Calculo que si lo paso desde el CMD ya se arregla. Sí, sí, sí. Listo.
Entonces, hasta ahora lo que hicimos fue trabajar un repositorio de manera local, pero también podemos trabajar y sincronizar lo que tenemos en local con un repositorio remoto, pero eso lo vamos a dejar para más adelante. ¿Sí? Entonces, lo que quiero que ustedes se tomen el trabajo, sigan haciendo estas preguntas. ¿Cuáles son los comandos básicos? Que algunos ya los vimos.
Git ad, Git Comit, ¿sí? eh gitpol, git push, que son para subir, para bajar. Ahora lo que les recomiendo es que se abran una cuenta en GitHub. GitHub es una plataforma en la nube que ustedes van a poder copiar y llevar todo lo que tengan local, subirlo ahí arriba como si fuese un Google Drive, ¿sí? como si fuese una copia de lo que tienen en el local en ese repositorio y después desde cualquier máquina van a poder clonarse esos esos datos, ¿sí?, y esos archivos o hacerse lo que se conoce como un fork, una copia a su propia nube. Yo, por ejemplo, les dejé e a ver,
sí, para poder ver lo de programación orientada a objetos. Denme un segundito. Yo les dejé un repositorio, ¿sí? Que ahí les voy a copiar dentro de la cuenta del centro de graduados. Y se los dejé también. Ahí les pasé la dirección, se los dejé también en el Drive.
en el Drive van a tener el PDF de hoy más un TXT con e justamente este este repositorio. ¿Sí? Entonces, cuando ustedes se generan una cuenta en GitHubat, que les recomiendo que lo hagan, van a poder empezar a eh subirse cosas que tengan localmente en esa cuenta o incluso hacer lo que se conoce como un fork.
Un fork es copiarse el repositorio de otra persona que la tiene en la nube en en el mismo eh GitHub, copiárselo en en su usuario. En este caso, yo estoy con el usuario mío de Ofacito, pero estoy eh teniendo acceso, como soy colaborador del centro, tengo acceso también a esto. Sí. Entonces, acá, ¿qué qué van a tener? van a tener un archivo, una un repositorio que yo les voy a ir subiendo por clase los códigos que vamos a ir usando.
¿Sí? Entonces, una manera de que ustedes puedan ir trabajando todos estos códigos es justamente haciendo uso de los repositorios. Entonces, ¿cómo podemos trabajar con esos repositorios? ¿Cómo puedo bajarme un repositorio que está en GitHub? Hay un comando que se llama git clone. Git clone lo que permite es sincronizar todos esos archivos, toda esa carpeta, ¿sí? Y meterlo dentro de mi máquina.
¿Sí? Entonces, para poder hacer eso, lo que necesitamos es esta dirección que yo les acabo de pasar, que es la dirección del repositorio en GitHubat. ¿Sí? Entonces, yo me voy a copiar esa dirección que es la que les acabo de pasar. también se puede bajar como si fuese un zip y abrir el zip. Sí. La ventaja de hacerlo esto con con clonarlo es que estamos manejando los comandos y estamos trabajando de una manera un poco más profesional y haciendo esos controles con el ZIP.
También vamos a bajar el repositorio e lo descomprimimos y lo vamos a tener, pero no estamos haciendo el uso de de Git. Sí, lo estamos usando con como un zip. Sí, Alejandro, estás muteado. Que que justo estaba señalando, veo que GitHub tiene un desktop, ese application, eso eh sí, pero más adelante se los voy a ir explicando. Tratame de de seguirme en la clase porque si no nos vamos a desvirtuar mucho.
Sí, yo voy yo les voy a ir diciendo, si te animás, bajalo y y revisalo y investigalo, pero hay hay un una aplicación de GIHub desktop para poder trabajar. Sí. Bueno, entonces eh ¿qué podemos hacer? Por ejemplo, si yo estoy en mi usuario, yo podría hacerme una copia exacta en mi GitHub dentro de lo que es el eh el entorno en la nube. ¿Sí? Entonces, ¿cómo hago eso? Acá con un fork.
Yo puedo venir acá y esto le hago clic a este botoncito y me va a decir se te va a copiar este mismo repositorio en tu usuario. Entonces yo le hago un clic acá y me va a decir el nombre de usuario, la copia del repositorio, que le voy a poder cambiar el nombre si quiero o no, y hacerme una copia exacta de lo que está ahí. Es un fork. ¿Sí? Entonces, me hago una copia exacta, le hago un crear y entonces dentro de mi usuario ahora voy a tener un IA Python para principiantes que va a ser una copia exacta de lo que tiene el otro repositorio, pero ahora esta es mía. Entonces, yo acá sí le voy a poder agregar, quitar, modificar, lo voy a
poder sincronizar con lo que haya hecho el centro de graduados. Sí, en el que es el del centro de graduado, si el centro de graduados no me da permiso, no puedo modificarlo, solamente puedo bajarlo. Sí. Y y mirar cómo está hecho. Entonces, depende lo que yo quiera hacer.
Si yo quiero tener una copia para poder manipularla a mi gusto, la puedo eh manejar como si fuese un fork. Sí. Y siempre voy a poder sincronizar el fork. Si hay si ellos en el centro de graduados hicieron un cambio, puedo acá hacer un sync y automáticamente se me va a ir sincronizando y a la vez yo voy a tener permisos de trabajar con este archivo. Sí, con este repositorio. Esta es una forma. Sí, Fer.
Eh, y esto me avisa que se hizo un cambio. Claro. Acá vas a ver si estás al día o no. Acá dice que estás al día. Y si hay cambios te va a decir, "Che, hay tantos comits que ellos hicieron que vos no tenés." Entonces podés sincronizarlo, por ejemplo. Okay. Entonces, por ejemplo, el proyecto genera un repositorio y lo comparte con todos los integrantes del proyecto y todos los integrantes se hacen su fork.
Sería una forma, una buena forma de trabajar, ¿sí? Porque vos podés manipular el for sin interferir en lo que está haciendo el proyecto. Sí. Okay. Pero digamos alguien lo tiene que generar y compartir. Exacto. Okay. Sí. Eh, hay es mucho más amplio todo esto. Yo le estoy dando una introducción nada más. Sí. Esa es una forma de trabajar y yo después de acá puedo hacer lo mismo. Ahora, fíjense que la dirección cambia.
Ahora es mi usuario con el nombre de repositorio que yo le haya puesto. Sí. Lo que me puedo bajar ahora. Esto es hacer un fork, lo otro es clonar. Sí, clonar es bajárselo a su máquina. se pueden bajar su versión, que si ustedes tienen permiso la van a poder mantener sincronizada también local y y remoto, así como vemos acá en la en la imagen usando estos comandos de Git Push es pasar lo que tengo en local, pasarlo al remoto y con gitol lo que tengo en remoto se sincroniza con el local subo o bajo cambios, pero tengo que tener permisos en ese repositorio.
tiene que ser un un repositorio que yo sea colaborador o que sea un repositorio mío para poder hacer uso de estos comandos. Si es un repositorio que no es mío, bueno, hay otros comandos y otras formas de trabajar que son los famosos pull request, donde yo le pido una modificación y eso lo tiene que aprobar alguien para poder incorporarlo, pero bueno, eso ya es un trabajo más colaborativo y de ramas, ¿sí? Entonces, si ustedes quieren poder mantener esto con git push, lo que hacen es subir lo que tienen en local a su repositorio y
con gitol lo que hacen es bajar lo que está en el repositorio remoto a el repositorio local. Pero para poder hacer eso, primero tuvieron que haberse clonado localmente ese repositorio, ¿sí? Entonces, cuando ustedes se clonan el repositorio, si es de ustedes, van a poder hacer estos comandos de sincronización.
Si es un Si de otra persona, cuando quieran colaborar con esa otra persona, van a tener que pedirle que incorpore algún cambio. Esa es la diferencia. Sí, eso después lo vamos a ver más adelante. No quiero no quiero ahondar mucho en eso porque quiero que nos quede tiempo para ver la parte de programación orientada objetos. Sí, Fer.
Y el que genera el repositorio sabe, digamos, ve a quién se lo compartió. Sí, sí, sí, sí, sí. Si vos vos cuando generás un repositorio en la nube, lo puedes eh generar privado o público. Si lo dejas público es de lectura para cualquiera y nadie te puede incorporar cambios, salvo que vos lo autorices. Si lo dejas privado, solamente lo pueden ver las personas que vos nombres como colaboradores.
Pero yo veo que vos que vos estás conectado y te los bajaste, una cosa así o Claro. Okay. Okay. Sí. Eh, cuando uno lo deja público es es de lectura para todo el mundo. Es código abierto, lo puede ver todo el mundo. Cuando uno lo deja privado, solo uno lo puede ver y puede seleccionar qué usuarios de GitHub pueden eh verlo y trabajar y le puede dar permisos de incorporar, permisos de quitar.
Pero bueno, eso ya es un trabajo colaborativo que es mucho más avanzado. Yo hoy lo que les quería dar era esta introducción y como quiero que empecemos a trabajar con Git, sí, yo les armé ese repositorio que acabo de hacerme un fork. Sí. Y lo que voy a hacer ahora es en vez de clonarme, eh, que también lo podemos hacer, en vez de clonarme lo del centro, me voy a clonar este fork que me acabo de hacer.
Se puede hacer de las dos maneras. Sí. Eh, veo una manito levantada. Orfelia. Sí, Omar, te consulto. Eh, acá cuando vos dijiste que se puede sincronizar el for que tenemos en estamos los dos, si hay dos partes, por ejemplo, el centro de graduados hace una sube un archivo, lo modificando cuando haces sincronización del fork, lo único que haces es bajarte los cambios.
Y pero si yo modifiqué el archivo en tu en tu fork, en tu copia de en la nube se sincroniza con tus cambios. Lo único que haces es incorporar lo que haya yo hecho el centro. Ah, okay, perfecto. Listo. Gracias. Sí, no tenés permiso de escritura en la del centro, solo en tu forma. Esa es la diferencia. Ahí está. Buenísimo. Ahí va. Eh, voy a compartir el el navegador, así ven de lo que estoy hablando.
Sí, cuando ustedes le hacen clic acá, yo acá me hice un fork y estoy, esta es una copia, es un forkit de la del centro de graduados. Yo puedo sincronizar los cambios, ¿si? Y me puedo bajar todo lo que haya hecho el centro de grado y lo puedo compartir acá. Y lo que hago es juntar lo que ellos hicieron con lo que yo venga haciendo. Sí, si lo manejo con el fork, si lo manejo directamente con el centro de graduados, fíjense que no tiene esa opción acá.
Simplemente lo que puedo hacer es, salvo que ellos me den permiso de escritura como colaborador, lo único que puedo hacer es bajármelo. Sí, esa es la diferencia. Les cuento para que sepan, ¿sí? que que están estas opciones. Entonces, ¿qué vamos a hacer? Me voy a bajar, por ejemplo, ahora voy a trabajar con con el fork. Sí, con este fork me voy a bajar ahora mi esta dirección.
Voy a ir a la terminal en la máquina virtual. Voy a minimizar el el visual. Sí, que ahí teníamos ese mi taller. Lo voy a voy a cerrar este temporalmente para que no me ocupe. Sí. Bueno, esto esto que que acabo de hacer lo voy a dejar acá y me voy a hacer una carpetita nueva. Le voy a poner curso para diferenciarlo y la voy a abrir en eh en una en una terminal.
Sí, en este caso, como tengo Git, eh se puede abrir acá en directamente en la terminal. También es una terminal como la de la de DOS, la la común, solo que aparece con estos colores y me aparece acá el simbolito. Sí, esa es la diferencia, pero lo podemos hacer en cualquier terminal, lo vamos a poder ejecutar.
¿Sí? Entonces, yo me voy a abrir acá, lo voy a abrir con el explorador para que vean lo que va a suceder. Y parado en este en este lugar, lo que voy a hacer es un CMD para abrir la terminal y voy a escribir git clon y le voy a pegar la la dirección, ¿sí? Que eh que teníamos de el repositorio. Sí, me voy a ir a la a la página web de de mi fork. Voy a venir acá y le voy a decir copiar.
Sí, me copio la dirección, la copio, vuelvo al entorno de de trabajo que que veníamos trabajando. Sí. Y le pongo git clone y pego esa dirección. Bueno, a ver, ¿por qué no se me está copiando? Denme un segundo. Ahí está. Sí. Entonces le copio la dirección. Fíjense lo que va a suceder en esta carpetita. dentro de la carpeta curso. Cuando yo le doy un enter, lo que va a suceder es lo siguiente.
Está medio lenteja. Vamos de nuevo. Ahí dice clonando el repositorio. me generé una carpeta y me agregó todo lo que tenía ahí adentro. Fíjense que me generó una carpeta con el nombre del repositorio y todos los archivos y, incluso tengo el archivito oculto de Git. Sí, si ustedes hicieron lo mismo, ya van a tener todo disponible ahí para que trabajemos ahora y hagamos las pruebas cuando veamos la parte de programación orientada objetos.
Entonces, yo ahora puedo venir acá, botón derecho, abrir con Visual Studio Code y ahí tengo los códigos si los quisiera usar. Si no lo quiero abrir de esta manera, puedo abrirme directamente el repositorio, no solamente esa carpetita.
Entonces, me voy, me voy una carpetita para atrás y le pongo abrir la carpetita para atrás. Voy a decir que sí. Y fíjense que acá tenemos una carpeta de la clase 11, un git ignore. Este git ignore es para poder escribir qué cosa yo no quiero que Git les haga seguimiento para no tener que estar y yo poder hacer un git ad y no tener que estar escribiendo archivo por archivo.
Yo puedo hacer un git ad punto que le haga seguimiento a todo menos a lo que está acá dentro. ¿Y qué le puse acá? Las carpetas Bend, las carpetas M. que son los nombres que solemos usar para los entornos virtuales, por ejemplo. Sí. Y si me voy a ver acá, vamos a ver todo el historial de los cambios que yo le fui haciendo. Sí.
Y acá vemos que como esta carpeta es un clon de lo que está en la nube, tengo eh el puntero, o sea, el lugar en que estoy en la nube, en qué lugar estoy. Justo estoy en el tercer comit y localmente en qué lugar estoy. Sí. Entonces están sincronizados el directorio de la nube con mi directorio local. Por eso vemos acá la nubecita rosa al mismo nivel que este iconito que dice M.
Si yo ahora hiciera alguna modificación a estos a esta carpeta, ¿sí? Por ejemplo, y como esto es un fork y no estoy tocando el del centro de graduado, lo voy a poder sincronizar sin problema. Vamos a suponer que vengo acá a un archivito, voy al ritmi y le agrego soy Omar. Sí, estoy modificando un archivo. Ah, ya. Ahí va. Lo salvo. Entonces ahí me dice, "Tenés una modificación.
Este archivo está modificado. Si me voy acá a la parte gráfica dentro de Visual, lo que es Git, me dice, "Che, hay cambios en ese archivo. ¿Lo querés agregar al staging?" Bueno, entonces lo agrego al staging. Ya está. Ya no no figura como cambio pendiente, está como en temporal.
Y ahora le puedo agregar un commit y le voy a poner agrego mi nombre. Le hago un commit y fíjense que ahora si yo me voy acá a la nube está mi m local que tiene un commit más y el de la nube no tiene esto. Sí, fíjense que la nube quedó por debajo, la rama de la nube quedó por debajo y la mía quedó un commit más.
Y acá me dice, lo que estás haciendo es querés sincronizarlo con lo que está en la nube, con lo que está en el repositorio remoto. ¿Qué estamos haciendo acá? Lo que estamos haciendo, estamos en esta instancia. Como yo me cloné un repositorio remoto a mi local, ahora tengo la posibilidad de hacer git push o de git pull, que es bajarme los cambios. Entonces, yo lo que voy a hacer ahora es un git push.
Voy a subir este cambio que acabo de hacer. ¿Cómo me voy a dar cuenta de eso? Si me voy al navegador, vamos a ver que acá dentro, ¿sí? En este archivito, le voy a dar un F5 para que se refresque. Vamos a ver que tiene tres commits. El último fue hecho el día de ayer, pero acá no tiene esa modificación. Sí.
Entonces, cuando yo vaya ahora al visual y le diga, "Sincronizá, subí el cambio, lo que estoy haciendo es un push. Sí, fíjense, a un push sincronizado, me va a decir, esto va a sincronizar hacia el repositorio. Le voy a dar que sí. Estos dos se van a poner al mismo nivel. Acá me está diciendo, bueno, que me que que se quiere sincronizar.
Tengo que conectar, ¿no? Porque acá no la había usado nunca la cuenta. La tengo que conectar. Ahí me dice que ya está eh autenticado. Perfecto. Ahora ya puedo cerrarlo. Para eso tuve que tener la cuenta en GitHub. Y ahora fíjense que me quedó ya sincronizado. Y si yo, no sé si llegaron a ver el navegador, no sé si lo estaba compartiendo, pero la primera vez me abrí una ventanita en el navegador, sí, acá que me decía que había que sincronizarlo.
acepté la sincronización de la del visual, la autoricé a que se conecte al GitHub y a partir de ahora si yo le hago acá refresco, vamos a ver que ahora tengo cuatro commits. Uno que hice hace 2 minutos y me quedó actualizado esto. ¿Sí? Y se fijan acá, yo tengo una diferencia con el del centro de graduados. Tengo un commit más. Sí.
Y acá estoy mirando esa sincronización. Si yo quisiera sincronizarlo, le tendría que pedir al centro de graduados que agregue esto. Pero bueno, ya es otro trabajo colaborativo. Sí. Entonces, tanto si yo modifico acá eh yo acá también puedo modificar, por ejemplo, el Ritmi. Hola, soy Omar Facito. Estoy modificando desde el remoto.
Hago un commit. El commit dice update del Redmi. Listo, ahí se actualizó. Ahora, cuando yo voy a a la máquina, lo que va a suceder si hago, si refresco acá, ¿no? Para ver, voy a ver que eh voy a tener distintas eh puedo hacer hacer un pull, ¿sí? Un fetch, es decir, eh ver qué cambios subo. Entonces, puedo bajarme, dice, agrego mi nombre.
Si refresco acá, me va a decir de que tengo un un cambio. Sí, fíjense que ahora me dice, hay un cambio, hay un pull pendiente que tenés que bajarte. Lo querés bajar, fíjate que la nube está más avanzada de lo que vos tenés. Y acá está el commit. Le digo, sí, lo quiero sincronizar. Fíjense que acá en el RMI no está ese texto, pero si yo ahora lo sincronizo, ¿sí? Ahora ya tengo la misma versión de lo que está hecho en remote.
Sí, ahí hicimos todos los comandos básicos de Git. Sí, vamos bien. Esto requiere practicar, requiere probar. Sí. Eh, no sé quién había hablado. Yo que dije mucha práctica porque tiene mucha Sí, sí, sí, sí, sí. Yo les dejé en en este grafiquito que les en este grafiquito que les compartí, sí, están los cinco comandos que más van a usar.
Git ad, git commit, git push para subir el remoto, git pull para bajar y en caso de que hayan puesto algo en temporal y quieran sacarlo, git reset. Sí, pero bueno, eso es esa es la introducción que les quería dar con Git para que vean qué es lo que estamos trabajando. Y ahora vamos a empezar a trabajar los archivos. Sí, en este repositorio que yo les les acabo de de mostrar, vamos a ver lo que es programación orientada a objeto.
Todos los ejemplos que vamos a utilizar, yo se los dejé en ese repositorio. Entonces, ¿qué voy a hacer a partir de ahora? Les voy a dejar una carpetita en ese repositorio. Ustedes lo único que van a tener que hacer es sincronizarla. Eh, les voy a dejar una carpetita por cada clase con los códigos. ¿Sí? Entonces ahí van a van a poder ver los códigos de Python y los vamos a compartir de esa manera.
¿Sí? Entonces, ahora clase 11, acá tenemos todos los eh archivos que vamos a usar en la clase de hoy. ¿Sí? Entonces, vamos a cerrar momentáneamente el temario de de Git. Más adelante vamos a seguir retomándolo. Eh, usen chat GPT para preguntar qué es una rama, qué es esto, qué es lo otro para poder ir familiarizándose.
Eh, no hay mejor manera de aprender a usar algo que metiendo man. ¿Sí? Entonces, ¿qué vamos a hacer ahora? Vamos a hablar en este ratito que nos queda sobre una introducción a programación orientada a objetos y en la próxima clase vamos a ampliar mucho más esto de programación orientada a objetos. Entonces, dentro de la carpetita de la carpeta del repositorio que ustedes cuando se lo clonen y lo tengan eh eh localmente para trabajarlo con el visual, van a poder trabajarlo.
Y acá les dejo todo lo que vamos a ir usando el día de hoy. En la carpeta clase 11 van a tener todo. Sí. La clase 12 van a tener lo de la clase 12 y así. Entonces vamos a ir a la presentación. Se va a bajar todo conjuntamente, no hay que bajar uno por uno. Se va a bajar, ¿no? No, por eso ustedes ustedes lo único que van a tener que hacer es un pull, un un push, o sea, bajarse, sincronizarlo.
Si ustedes ya lo tienen guardado en un lugar, a ustedes les va a aparecer cuando se paren acá les va a aparecer de que yo les agregué algo. Entonces, ustedes se lo bajan y automáticamente van a tener ahí eh localmente también. Sí, gracias. Cuando decís clonen es el fork. Sí, el fork.
O cuando vayan al fork les va a decir, eh, a ver, para, voy a ir al fork. Porque vos dijiste, se puede hacer un fork o se puede clonar. Exactamente. Lo que puede, si van a usar el fork, es lo que les recomiendo para que ustedes puedan manejarlo de manera independiente las modificaciones que yo haga.
Cuando ustedes hagan el fork, lo que les va a pasar, yo acá estoy en este es el for del centro. Cuando yo haga una modificación en el for, a ustedes acá les va a parecer de que hay cambios. Por ejemplo, cuando agregue la carpeta 12. Entonces, ustedes ponen acá sincronizar con sincronizar el fork. Acá me dicen, no hay ningún commit, estás al día, ¿ves? Pero ustedes les va a decir, si yo le subo un commit al fork, ustedes van a les va a aparecer acá para que hagan sincronizar el fork y ahí van a poder bajárselo después al local. Sí, la clase que viene vamos a hacer ese trabajo. Ahora que si ya tienen el fork, les voy
a enseñar cómo llevar del repositorio original al fork y cómo llevarlo del fork a su local, pero lo vamos a hacer la clase que viene. Sí. Okay. Sí. Este, yo acabo de de crearme una cuenta en Ghub. Eh, lo que quiero saber es cómo reconocer que estoy en mi cuenta y no en la del Centro de Ingenieros, porque no me doy cuenta bien todavía en dónde tengo que ver cuándo es la mía y cuándo es la de ustedes. Te va a aparecer el nombre de usuario acá arriba, mira.
Ajá. Ah, okay. Okay. Y después aparte vas a ver el loguito acá a la derecha tenés tu perfil. Y a derecha mi perfil en GitHub. En GitHub, exacto. Ah. Okay, está bien. Creo que tengo una genérica porque todavía no subí ninguna. Entonces, sí, sí, sí puede ser.
Si no subiste ninguna foto, nada, es yo, porque puse una foto mía, pero sí te va a aparecer el nombre de usuario acá. Okay. Okay, gracias. Acá siempre vas a ver que dice usuario barra repositorio en donde estás parado. Entiendo. Entonces, si está mi usuario, lo que estoy viendo está en mi eh en mi repositorio. Exacto.
Si yo ahora me voy acá, fíjate, ¿ves? Acá estoy en el repositorio del centro de graduados, pero en el nombre repositorio con mi usuario. Lo puedo ver porque es público y estoy mirando el otro repositorio para saber siempre en dónde estás. Es este que está acá. Es el de la derechita. Perdón. Justo mira la otra pantalla. ¿Qué? ¿Cómo te fuiste de un repositorio al otro? Como acá abajo dice que este es mi repositorio, que es un fork del centro de graduados, si yo le hago clic acá, me salto al original. Okay, okay, entiendo.
Sí, sí, sí. Pero bueno, yo hoy quería presentarles esto porque quiero que se acostumbren a usar kit porque me parece que es una buena práctica como programadores y que les va a servir. Sí. Entonces, es una manera de de obligarlos a que vayan practicando también esto. Entonces, vamos a arrancar con el temario de programación orientada a objetos.
Sí, para eso voy a volver a la presentación y cuando haya alguna práctica vamos a tomar los códigos en el visual. Sí. Programación orientada a objetos. ¿Qué es esto de orientado a objetos? La programación orientada a objetos o p o es un paradigma de programación. ¿Qué es un paradigma? Es una forma de organizar el código y todo lo que nosotros escribimos y una manera de programar.
que tiene cierta organización y ciertas reglas. En este caso, la programación orientada objetos está basada en un concepto, ¿sí?, que todo ronda alrededor de objetos. ¿Qué es un objeto? En lugar de tener lo que vemos en el paradigma lineal, la programación lineal, donde teníamos un control de flujo y nosotros teníamos el if para bifurcar las funciones para hacer algo repetitivo.
Bueno, en programación orientada a objetos, un programa va a estar compuesto por muchos objetos individuales y cada uno de esos objetos van a tener ciertas capacidades y van a poder hacer ciertas tareas, ¿sí?, que son específicas de ese objeto. Entonces, estos objetos van a formar parte del programa y van a empezar a cooperar entre sí, van a empezar a mandarse mensajes entre sí y hacer tareas de manera conjunta.
Entonces, cada uno de estos objetos en realidad tienen cierto comportamiento, ¿sí? van a tener un estado, van a tener unas variables y van a tener un comportamiento que le permite relacionarse con otros objetos dentro de ese ecosistema del programa. Ahora, cuando veamos bien los gráficos se van a dar cuenta de qué les estoy hablando, ¿sí? Pero orientado a objeto es en vez de pensar una secuencia lineal de programación vamos a tener objetos que tienen capacidades y que pueden hacer tareas.
Un objeto puede ser la representación de una entidad de la vida real, ¿sí? Por ejemplo. Entonces, un objeto lo que podemos hacer es crearlo usando lo que se conoce como clase o plantilla, ¿sí? Un un template de lo que es un plano, ¿sí? De lo que es ese objeto de cómo construirlo, un molde.
¿Sí? Entonces, una clase va a representar todas las características que debería tener ese objeto y después nosotros vamos a poder generar tantos objetos como necesitemos de esa clase. ¿Sí? Ahora vamos a ver bien puntualmente es cada una de estas palabras que les estoy nombrando. Python en sí es un lenguaje de programación orientado a objetos. ¿Por qué? Porque dentro de Python todo es un objeto.
Cuando nosotros estuvimos trabajando con Python, vimos, por ejemplo, listas. Sí, si nosotros vamos a la documentación de las estructuras de datos, por ejemplo, las listas, nosotros estuvimos usando el objeto, ¿sí?, de la clase lista y vimos que teníamos distintos métodos que podíamos usar. teníamos remover, pup, ordenar, extender, insertar.
Entonces teníamos lista punto y lo que queríamos usar. Sí, nosotros declarábamos una variable, por ejemplo, la variable lista y después usábamos los métodos o las acciones que tenía ese objeto. Es decir, nosotros ya venimos usando el paradigma de objetos al usar el lenguaje Python. Lo mismo va a suceder cuando trabajemos con alguna librería. Por ejemplo, la librería SQLite.
SQLite es una librería que nos va a permitir trabajar con la base de datos SQLite. Yo voy a generar una instancia de un objeto de esa base de datos. Sí, voy a poder generar, por ejemplo, de el objeto SQL, voy a usar el método conexión. Y el método connect me permite conectarme una base de datos. Entonces, voy a generar una conexión a esa base de datos.
O puedo pedir un cursor que vemos acá, ¿sí? Que lo que hace es ejecutar una consulta a la base de datos. Entonces, tengo un objeto para hacer consultas. ¿Sí? Entonces, un objeto en realidad es la representación de una entidad, de algo que puede tener un estado y que puede tener también características o funciones a usarse.
Lo que vamos a hacer cuando estemos resolviendo problemas en realidad es hacer que todos estos objetos se comuniquen entre sí. Nosotros cuando estábamos programando la programación lineal, lo que hacíamos era teníamos un dato, ese dato se lo dábamos a una secuencia de programa, se procesaba todos esos datos y eso lo devolvía, nos devolvía una salida.
A veces esto lo encapsulábamos incluso dentro de una función que para poder usarlo de manera repetitiva, ¿no? Entonces, en la programación secuencial, que es otro paradigma, que es el que veníamos usando hasta ahora, sí, nosotros podíamos armar toda la secuencia paso a paso.
Si que que empezábamos a armar funciones, teníamos que esas funciones reciben un dato y devuelven algo. ¿Sí? Ahora, eso que nosotros hacíamos como función y que encapsulábamos todo eso y para que esa esa parte del código no la tuviéramos que escribir todo el tiempo, ¿sí? Podemos usar un concepto similar con los objetos. Un objeto sí va a estar compuesto por un poco de código y un poco de datos que va a guardar.
¿Qué datos va a guardar? datos propios, datos autónomos de su estado, de lo que es ese objeto y el código va a ser cosas que puede hacer ese objeto. Entonces, un objeto en realidad es un poco de código más un poco de datos. El código va a ser tareas, comportamientos, funciones que nosotros les vamos a programar y los datos van a ser variables o datos propios de ese objeto que van a ir guardándose y que van a a ser parte del objeto.
Por ejemplo, supongamos que tenemos Sí, Alejandro, el hecho de que no sea lineal significa que puede interactuar en órdenes diferentes. Exacto. Okay. Exacto. Que yo ya no estoy pensando una secuencia lineal interrelacionado, digamos. Ahora, ahora lo vamos a ir viendo.
Cuando nosotros tenemos un problema muy complejo, por lo general lo que hacemos es dividirlo en problemitas más simples y empezar a atacar cada uno de esos problemitas más simple. Sí, supongamos que queremos hacer una tarea bastante compleja y armar un programa. Si ese programa tiene una secuencia de pasos que nosotros tuviésemos que hacer, lo que vamos a tratar es de modelar cada una de esas responsabilidades, cada una de esas tareas en pequeños programitas.
¿Sí? Cada uno de esos pequeños programitas, cada una de esas partes, cada una de esas tareas, la podemos representar como un objeto. ¿Sí? Entonces, este es un enfoque muy importante de la programación orientada a objetos. es dividir un problema grande en partes más pequeñas y comprensibles con responsabilidades bien especificadas.
Entonces, un problema grande podemos hacerlo y separarlo en pequeños problemitas más chiquitos. Por ejemplo, e tomar los datos de una lista, ordenarlos de mayor a menor y mostrarlos en pantalla. Entonces, yo podría tener un objeto que lo que hace es eh ser la lista, otro objeto que lo que hace es ordenarse, otro objeto que lo que haga es mostrarlo en pantalla y otro objeto que haga otra tarea.
Entonces, voy a tener un ecosistema que cada uno va a estar representado y va a tener ciertas capacidades. ¿Sí? Y lo que voy a lograr con esto es poder resolver con pequeños programitas una tarea muy compleja, ¿sí? que solamente se va a dedicar a eso. En los sistemas lo que se suele hacer es, por ejemplo, tengo una parte del sistema que se encarga del logueo de usuarios, tengo una parte del sistema que se encarga de levantar pedidos de ese usuario, tengo otra parte del sistema que se encarga de facturar ese pedido, tengo otra parte del sistema que se encarga de e, no sé, guardar eh el stock de después de
que se facturó. Sí. Entonces, cada una de esas partes va a estar compuesta por varios objetos. ¿O entonces, ¿qué me implica esto? Que voy a tener, por ejemplo, un objeto cliente, voy a tener un objeto producto, voy a tener un objeto factura. Y cada una de estas entidades va a tener responsabilidades, va a poder hacer distintas cosas. Lo que yo hago dentro de un sistema es que empiecen a relacionarse entre sí.
Sí, Alejandro. Bueno, entonces los objetos lo que hacemos es crearlos muteado, pero no me di cuenta. Si hay objetos dentro de otros objetos, o sea, si tenés grupos de objetos interrcionados, ¿no? Okay. Sí, puede haber grupos de objetos, pero eso es otra cosa. Ahí estás hablando en una librería. Sí.
Entonces, los objetos en sí lo que hacemos es crearlos para para poder usarse. ¿Sí? ¿Y cómo es que se usan? Bueno, van a empezar a mandarse mensajes entre sí, se van a empezar a pasar datos entre sí. Sí, eso de pasarse datos entre sí me permite tener objetos de distintos tipos. Por ejemplo, hasta ahora nosotros estuvimos trabajando con Python usando muchos objetos que ya vienen en Python.
Usamos objetos del tipo cadena, objetos del tipo entero, objetos del tipo diccionario, objetos del tipo lista. Sí. Y en nuestros programas lo que hacíamos es tomar un diccionario, pedirle al diccionario que nos diga que tenía dentro, según los datos que teníamos, se lo pasábamos a una cadena. Sí. Entonces, podíamos ir trabajando con objetos y usando los distintos métodos que tenían esos objetos.
Entonces, si pensamos al objeto como que está compuesto por una parte de código y una parte de datos, nosotros vamos a poder abstraer, decimos, un problema representándolo con un poquito de código y un poquito de datos. Es decir, cada objeto va a tener un comportamiento, una funcionalidad y va a tener algunos datos que van a ser propios de ese objeto.
Esto me permite hacer foco solamente en ese objeto y olvidarme del resto, de todos los demás detalles que son innecesarios. Es decir, yo puedo hacer foco en ese objeto y ese objeto tiene vida propia, tiene cierta funcionalidad, tiene ciertos datos y no me importa el resto.
Yo me puedo así como hacemos con las funciones, yo sé que esta función le manda un dato y me devuelve algo. Bueno, lo mismo podemos hacer con los objetos, ¿sí? Eso se llama abstracción. Yo puedo modelar un comportamiento, darle algunos datos y olvidarme del resto del sistema haciendo esa representación. Por ejemplo, puedo tener un objeto diccionario, que al objeto diccionario yo tengo métodos para agregarle datos, tengo métodos para leerle datos y después están los datos propios de ese diccionario.
¿Sí? Ahora, yo una vez que ya tengo el objeto y que ya tengo programado cómo se comporta, no me interesa cómo lo hace internamente, después lo uso. Eso me permite abstraerme del código de cómo lo hace. Sí. Cuando yo tengo, por ejemplo, un objeto que me maneja el stock de mi inventario en mi sistema de facturación.
Bueno, yo sé que en algún momento cuando hago una venta le tengo que decir a ese a ese objeto, ¿sí?, a esa clase le tengo que decir, "Descontad el stock tal producto." ¿Cómo lo hace? No lo sé. Yo me abstraigo de eso. Me olvido, pero ya sé que está programado ahí adentro.
Lo único que sé que le tengo que mandar el mensaje, "Desconta uno, ¿sí?" Y él me va a decir, "Listo, se descontó. ¿Cómo lo hizo? Bueno, él se encargó de hacerlo. Entonces, yo me abstraigo de ese problema, lo programé una vez, lo resolví y ya está guardado en ese objeto. Y lo otro que nos permite la programación orientada a objetos es que puedo encapsular esos problemas y trabajarlo de manera independientes.
Es decir, yo puedo modelar un comportamiento de una entidad, de alguna cosa de la realidad a través de ese poder de abstracción, pero eso también me permite que los demás no vean y no se enteren qué es lo que está pasando ahí adentro. Solo saben que si le piden o le mandan un mensaje, ese objeto va a responder de cierta manera.
Saben cómo comunicarse con el objeto, pero ¿qué hace el objeto internamente? está encapsulado, no lo veo. Entonces estoy protegiendo esa lógica. Sí, yo sé que si quiero programar y pedirle cuál es el stock de tal producto, uso un objeto de la clase stock y le digo, eh, ¿cuánto tenés de tal producto? Y me va a devolver la cantidad.
¿Cómo lo hizo? ¿Cómo lo fue a buscar? ¿Dónde lo buscó? A mí no me interesa. Eso está encapsulado. Yo sé que le mando un mensaje y me responde de una manera. Sí. Entonces, acá acabamos de ver dos aspectos importantes de lo que es la programación orientada a objetos, encapsulamiento y abstracción. Sí, la abstracción es algo de la vida real, olvidarse de todo el resto y modelarlo en un objeto.
Y el encapsulamiento justamente protejo todo lo que está ahí adentro y el resto del sistema no tiene por qué interarse. Lo único que tiene que saber es cómo comunicarse con mi objeto. Ahora, ¿cómo hacemos esto de trabajar entonces con la programación orientado a objetos? Bueno, hay ciertas palabras que vamos a empezar a usar. Una es la de clase. La clase es una plantilla, es el plano que define cómo hago para construir ese objeto.
Un objeto va a tener atributos y va a tener métodos, ¿sí? Es decir, va a tener variables y va a tener funciones que puede hacer, pero eso lo tengo que definir. ¿Se acuerdan cuando definíamos una función y después la usábamos? Bueno, acaba para ser igual. vamos a tener que definir una clase y después la vamos a usar.
Esa clase va a tener eh dentro de su definición los métodos y los atributos de esa clase. Los métodos van a ser los mensajes, es decir, qué funcionamiento tiene, todas esas funciones predefinidas que van a estar dentro de esa clase y que se van a utilizar como acciones que va a poder hacer ese objeto. Si por ejemplo, tengo un objeto usuario. Sí.
ese usuario va a poder loguearse, ese usuario va a poder borrarse, ese usuario va a poder modificarse. Sí, esos son los mensajes, los métodos, las funciones que puede hacer el usuario. Ahora, ese usuario va a tener ciertas variables o ciertos campos que son propios. El nombre, el email, el apellido, el teléfono, si está logueado o no está logueado. Sí, esos son campos, son atributos, son variables propias.
de ese usuario, que también los hace distintos de otro usuario. ¿Sí? Entonces, dentro de esos eh atributos o de esos campos, vamos a tener dos tipos. Unos que van a ser los atributos de instancia, es decir, los que pertenecen puntualmente a ese objeto y que lo hace diferente de otro.
y los atributos de clase que por ser parte de esa clase sí les corresponde. Ahora, después vamos a ver en con algún ejemplo qué es esto de atributo de clase y atributo de distancia. Más adelante y la próxima clase lo vamos a ver más en profundidad. Lo que quiero que les quede es que un método es una función, un atributo es una variable. ¿Sí? Entonces, acá tenemos comportamiento, código en las funciones y propiedades o atributos que van a ser variables.
Lo otro que vamos a tener es el objeto en sí. El objeto es una instancia, decimos, de una clase particular. Sí, en Python todo es un objeto. Cuando nosotros generábamos un objeto de un tipo del tipo lista, le poníamos un nombre de variable, ¿sí? Y por ser parte de esa clase tiene un montón de funcionalidad, pero después a esa a esa lista le agregábamos valores, ¿sí? Y podía tener una lista, dos listas, tres listas. Cada una de esas listas que tenía es un objeto distinto.
Ahora vamos a ver la diferencia entre instancias. ¿Sí? La realidad es que eh los objetos dentro de Python es la base de todo el funcionamiento de Python. Cada cosa que usamos en Python es un objeto, desde los enteros, los flotantes, eh las estructuras más complejas como los diccionarios, las listas, las tuplas, todos son representadas como objetos y como tal tienen datos que le puedo incorporar y también tienen ciertos comportamientos o funciones asociadas.
Por ejemplo, sí, para verlo esto eh un poquito más en detalle, ¿qué es un objeto? ¿Qué es un instancia y qué es una clase? ¿Qué es una clase en sí? La clase va a definir de manera abstracta, ¿sí? sin hacer específico, es simplemente decir cómo está compuesta esa clase. Es decir, vamos a tener ciertas características y ciertos campos que van a ser propios de esa clase.
Por ejemplo, tenemos la clase perro. Sí, el perro va a tener algunos eh campos, algunas propiedades, algunos atributos puntuales. ¿Qué atributos puede tener un perro? Bueno, puede tener una raza, un color, una edad. Esos son atributos de un perro.
¿Si? Entonces, yo acá estoy armando el molde de cómo voy a definir lo que es un perro. Entonces, la clase perro dice, "Tengo raza, color y edad." Ahora, el perro puede hacer distintas acciones, puede tener distintos métodos, puede hacer otras operaciones. ¿Qué operaciones puede hacer un perro? ¿Qué acciones puede hacer un perro? ¿Qué métodos puede tener? Bueno, puede ladrar, puede sentarse, puede correr. Sí.
Entonces, cuando yo defino una clase, estoy definiendo la forma, el comportamiento y qué cosas, qué propiedades, qué campos va a tener esa clase. Entonces, voy a definir una clase perro que va a tener atributos, raza, color y edad, y va a tener métodos, acciones, funciones que va a poder hacer. Entonces esta clase en realidad va a funcionar como un plano, como una fábrica de objetos. Sí, como si fuese un molde.
Entonces, yo tengo masa, supongamos que tengo galletitas, ¿no? Entonces, estiro la masa y después voy pasando por encima de ese de esa masa estirada, voy cortando con ese molde y voy generando distintas galletitas. Sí, voy a tener galletitas que son triangulares, galletitas cuadradas, galletitas en forma de estrella. Sí, pero ese molde es la clase y cada galletita sería un objeto.
Entonces, esta clase perro que estamos haciendo, yo la estoy definiendo con los rasgos compartidos de todos los perros. Todos los perros van a tener una raza, un color, una edad. Todos los perros van a poder ladrar. Todos los perros van a sentarse. Todos los perros van a correr. Sí.
Entonces, van a tener eso y lo que estoy haciendo es definir justamente esa entidad. algo de la vida real, sí lo estoy definiendo de algún de alguna manera, separándolo en atributos y métodos. Sí, Alejandro, eh, ¿cómo sabes cuáles son los atributos que necesitas para crear una clase? Y bueno, ahí está lo de tener poder de abstracción, es decir, poder modelar algo que yo necesite, que voy a tener que usar una variable. Ah, no hay no hay como una eh no no hay.
Vos puedes crearte el objeto que vos quieras. La puedes crear como quieras. Okay. Okay. Vos te creas el objeto que vos quieras. Vas a poner variables que vas a necesitar en el funcionamiento. Si a vos no te interesa eh largo de pelo en ninguna funcionalidad, no tiene sentido tener ese dato si no lo usas. El largo de pelo del perro.
¿Sí? Entonces, ¿cómo puede ser largo? ¿Corto, medio o largo? Ponele. Sí. Pero si yo ese dato no lo uso, ¿para qué lo voy a modelar? ¿Para qué lo voy a a armar? Cuando nosotros estamos modelando, estamos armando una clase, vamos a poner atributos que yo necesite y vamos a poner funciones que yo necesite para resolver el problema. ¿Sí? Bueno, entonces estos son los datos.
Esta sería la parte de los datos y esta sería la parte del código. Sí, los datos son las variables, los atributos y el código serían los métodos. ¿Y qué es esto de hablar de una instancia? Bueno, una instancia es una vez es cuando yo ya declaro y uso esa clase, cuando fabrico el primer objeto. Sí, uno puede tener una instancia de una clase o un objeto en particular.
Esa instancia, ese objeto real que cuando yo ya lo creé en tiempo de ejecución, ¿sí? En en la jerga de la programación decimos que ese objeto es una instancia de tal clase. Por ejemplo, puedo tener a LAI que sea una instancia de la clase perro. ¿Sí? Entonces, LAASI como perro, como individuo, va a tener algunas variables y va a tener algún comportamiento, va a tener un estado.
Entonces ahí es cuando hablamos de variables de estado o variables de clase. Entonces, yo tengo la clase perro. Ahora, cuando yo instancio esa clase, cuando agarro el molde y lo pongo encima de la masa y levanto el molde y me quedó cortadita la galletita con la forma, acabo de instanciar, acabo de fabricar un objeto. Ese objeto va a tener un estado.
Sí, por ejemplo, LASI va a ser de la raza coli, va a tener un color marrón, va a ser de va a tener una edad de dos y va a poder ladrar, sentarse y correr. Estas variables son propias de una instancia. Es el estado actual de este objeto. Este objeto se describe con estos atributos y esta funcionalidad. La si es un objeto.
La clase perro es la definición de lo que es un perro. Sí, esa es la diferencia entre clase e instancia. Pero yo podría tener otro perro y le puedo llamar Tony. Tony va a ser otra instancia de la clase perro, pero va a ser otro objeto distinto. ¿Por qué? Porque tiene atributos distintos. Entonces, voy a tener en memoria la representación de dos perros con valores distintos, ¿sí? Y con funcionalidades que vienen propias de ser perro. Sí.
Por ser perros, los tres tienen raza, color y edad, pero cada uno tiene su valor, cada uno tiene su representación y cada uno es un perro distinto porque le estoy nombrando de manera distinta, pero los tres tienen funcionalidad en común. Los tres pueden ladrar, sentarse y correr. Por lo tanto, estas son funciones de clase que las las heredan, las tienen por ser de la clase perro.
Sí. Esto mismo pasaba cuando generábamos una lista. Cuando nosotros en memoria instanciábamos una lista, decíamos, creé una lista y le ponía el nombre lista de amigos, por ejemplo. Bueno, lista de amigos era del tipo lista y por ser del tipo lista teníamos un montón de métodos, pero esa lista tenía componentes internos distintos y la lista de amigos no era lo mismo que la lista de ingredientes para mis recetas, por ejemplo. Sí.
¿Se entiende la diferencia entre clase y instancia? La clase es una idea, algo abstracto, una definición y la instancia es cuando la creo y ya la la pongo en memoria con algunos valores específicos. Sí. ¿Dudas, preguntas? Vamos bien. Muy bien. Gracias por la explicación. Entonces, objeto o instancia a menudo se suelen usar de manera indistinta, ¿sí? La palabra para poder eh instanciar una clase necesito crear un objeto.
El método, cuando hablamos de métodos, sí, son las habilidades que tiene ese objeto. Por lo general, vamos a nombrar los métodos con verbos. ¿Sí? Por ejemplo, cuando teníamos lazi, por ser de la clase perro, tiene la capacidad de ladrar, por lo tanto va a haber una función ladrar.
¿Sí? Entonces, ladrar va a ser uno de los métodos del objeto lá, pero también puede tener otros métodos, como habíamos dicho, sentarse, comer, ¿sí? Y todo eso van a estar programados, van a ser la parte de la programación de ese objeto. Entonces, generalmente cuando yo estoy e usando uno de los métodos que tiene ese objeto, solo va a afectar a ese objeto, no va a afectar a otro. Sí.
A por eso a ese tipo de métodos les decimos métodos distancia. ¿Por qué? porque solamente modifica los valores, las variables, los campos de ese objeto, salvo que sea un objeto que una función o un método que haga que se comunique con otro, pero lo único no está modificándole al otro, le está mandando un mensaje.
Sí, supongamos que ladrar sea que un perro le está ladrando a otro, ¿sí? Entonces, bueno, ladrar sería la forma de comunicarse, pero no le está modificando los valores internos, solo le está mandando un mensaje. Sí. Es decir, todos los perros pueden ladrar, ¿sí? Pero no todos van a ladrar específicamente, solo lo va a hacer al que se está ejecutando en ese momento.
Entonces, el concepto de método y mensaje, ¿sí? La idea esta de ir pasándose mensajes entre objetos es también usado de manera indistinta. Método, mensaje se suelen usar como como sinónimos dentro de la programación orientada a objetos. Sí. Ahora, ¿cómo definimos una clase en Python? En Python ya existen algunos objetos.
Para eso voy a compartir ahora todo mi pantalla, así lo podemos hacer mucho más rápido. Permítanme abrir cmd. Voy a abrir una una terminal muy rápidamente para usar el shell de Python. Sí. A ver si puedo agrandar un poquito esto para que se vea mejor. Ahí se va a ver mejor. Y se acuerdan que yo puedo escribir Python y entrar al shell prom de Python.
Sí, yo puedo decir, por ejemplo, X es igual a eh ABC. ¿Qué estoy definiendo ahí? en X. ¿Qué es ABC? Si yo hago un type de X, es un stream. Un stream. Un stream. Sí. Y se acuerdan cuando hacíamos esto me decía que era de la clase STR. Bueno, la clase STR es justamente una definición de una clase. Cuando yo estoy generando el X, estoy creando un objeto del tipo stream y como objeto del tipo stram características, van a tener funcionalidades y va a tener eh campos que voy a poder usar.
Sí, si yo me voy a a lo mismo con un con un float y con un in, me va a pasar exactamente lo mismo. Yo voy a poder decir, por ejemplo, decme ahora el type, decime ahora el type de eh 2.5 para hacer el mismo ejemplo que tenemos ahí. Este es de la clase float, es decir, es una instancia de un objeto de la clase float.
Si yo hago un type, pero del dos, me está diciendo que es de la clase entero. Es decir, todo el tiempo estuvimos usando clases y objetos dentro de Python. ¿Sí? Ahora, cuando yo uso la la palabra dir, puedo ver cómo está compuesta esa clase. Entonces, yo puedo hacer, por ejemplo, un dir X, que en este caso X era un stream.
Y cuando hago dir X, voy a ver que tengo distintos campos y tengo distintos métodos. Esos métodos son propios de esta instancia, de este objeto del tipo stream por ser de esa clase. Sí. con la palabra dir, con el con dir, puedo ver el comportamiento y la definición de cuáles son los métodos que tiene una clase. Sí, lo mismo me va a pasar con las listas.
Sí, yo genero una lista, hago el type de esa lista, voy a ver que es de la clase lis. esa clase list, si yo le digo unir, voy a ver que entre un montón de cosas aparece el método appen, clear, count. El count, ¿qué me devolvía? Me devolvía cuántos elementos tenía la lista. El el sort, ¿qué me hacía? Me lo ordenaba. El reverse, ¿qué me hacía? Me lo daba vuelta. Me ponía el primero al último y me invertía el orden. Sí.
Lo mismo pasaba con el diccionario. Yo genero un diccionario. Sí, nosotros podemos trabajarlo de esa manera. Y acá lo que estamos haciendo, fíjense que acá estamos usando list paréntesis, dick paréntesis. En vez de generarlo con, voy a hacer un i igual list, estoy usando un método. Este método list lo que estoy diciendo es creo quiero crear una lista, un objeto del tipo lista.
Yo puedo generar una lista poniéndole los elementos o simplemente diciéndole, quiero instanciar con esto que vamos a decir que es el constructor, ¿sí? El que instancia el objeto. Y yo acá puedo hacer un type ahora de ese i. Si hago un type de si, me va a decir que es de la clase lista. Y si hago un DIR DSI, me va a decir todos los métodos. que tiene esta lista.
¿Sí? Entonces, fíjense que podemos crear objetos, lo podíamos crear en las listas, por ejemplo, armándolo por por definición o usando un método que crea el objeto. Sí, lo mismo va a pasar con el diccionario. Y el diccionario también tiene sus propios métodos.
teníamos el get que me permitía traerme un ítem, teníamos key que me permitía traer todas las claves, ¿sí? Teníamos el values que me traía todos los valores, eso lo usamos. Y para crearlo, lo podíamos crear con los con los corchetes, con las llaves, perdón, o lo podemos crear usando un método de la clase DIC, que me permite construir un objeto simplemente diciendo dict y crear esto.
Este DIC que vemos acá es un constructor. Ahora vamos a ver más adelante qué es esto de un constructor. Sí, pero todo el tiempo estuvimos usando objetos dentro de Python. Vamos bien. Sí, sí. Okay. Entonces, vamos a hacer un ejemplo de una clase. Yo acá para definir una clase, así como en las eh en las funciones teníamos las palabras reservada def, en Python tenemos la palabra reservada class.
¿Sí? Entonces, yo puedo escribir class, el nombre de la clase. Sí. Y class va a ser una palabra reservada de Python. Es una es una palabra del lenguaje. No la puedo usar porque se me ocurre. Cada vez que yo pongo class, lo que le estoy diciendo es lo que sigue es el nombre de la clase. ¿Sí? En este caso, class party animal. Supongamos que se hace una una fiesta en la selva. Sí.
Y necesito una clase para contar cuántos animales van a la fiesta. Sí. Entonces, inicializo un atributo. Esta va a ser la clase para crear ese objeto. Ahora te doy la palabra, Alejandro. Déjame avanzar un cachito, ¿sí? Porque si no no vamos a llegar. E entonces, ¿qué estoy haciendo acá? Estoy definiendo esa clase. Esa clase va a tener unos datos.
En este caso, todos los objetos del tipo party animal van a tener esa variable X. Sí, que la voy a inicializar en cero. Es un tienen un campo que lo inicializo en cero. Y después van a tener un código, un poco de código, un método, una función. Esa función dice party. Y acá hay una un parámetro que reciben. Reciben un parámetro de sí mismo.
Y acá por lo que veo es toma el valor de x y le suma uno y le va armando un contador. Cada vez que yo llamo a esta función incrementa en uno esta variable. Sí, con esto que tengo acá arriba, esta parte que está acá es la definición de la clase. ¿Sí? Ahora, esto que tengo acá, estoy construyendo un objeto, la estoy instanciando, estoy diciendo que esta variable va a ser un objeto de esta clase. Sí, acá estoy usando el constructor, decimos, de la clase.
Estoy llamando, así como llamábamos a una función acá, estoy llamando a la clase. Entonces, a partir de ahora, este AN es un objeto, es una instancia de esta clase que internamente tiene un campo y tiene una función. Y como la tiene internamente esa función, yo la voy a poder ir usando varias veces. ¿Sí? Entonces, esta parte que estoy haciendo acá, le estoy diciendo, "Bueno, a esta instancia de este objeto, lo que quiero es que ejecutes el método party." Entonces, va a ejecutar la función party.
La ejecuto una vez, la ejecuto dos veces, la ejecuto todas las veces que yo necesite, pero esta función, este código va a estar metido dentro del objeto, va a ser parte del objeto. Sí, esto que tengo acá es como decir tengo de la clase party party animal, quiero usar el el la función party y le quiero pasar esta propia instancia, este propio objeto. No quiero otro, quiero este propio.
Sí, ese este propio que le estoy pasando es este self que le estamos pasando acá. Sí, esa palabra self es un estándar que se usa para hacer referencia a la misma instancia. Como puedo tener varios objetos de de esta misma clase en memoria, yo le estoy diciendo, quiero que te modifiques, pero vos, no otro, vos mismo.
Sí. Entonces, vamos, ahora lo vamos a ver en código este ejemplo. Sí. Entonces, yo defino una clase, le pongo un atributo, le pongo una función y después la uso, la creo y la uso. ¿Sí? Entonces, para poder ejecutar esto, lo que vamos a hacer es ejecutar el archivo que tienen ahí dentro del repositorio en la clase 11, que se llama pa
rty.p. Cuando lo estemos ejecutando la primer línea, todo esto que está acá es la definición de la clase. Acá lo que estamos haciendo es generar un espacio en memoria que adentro va a generar un campo que se va a inicializar en cero y va a tener una función ya programada que se llama party. ¿Qué hace esa función? hace, lo que hace es tomar de sí mismo la variable X y le suma uno y la vuelvo a guardar en sí misma y después aparte me muestra un print.
Entonces, cada vez que yo llame, sí, este self, le estoy diciendo, "Tomá tu propia instancia, ¿sí? Fíjate vos mismo tu campo X." Y por eso acá le estoy pasando la instancia y le digo de vos mismo tomá el valor de x y a ese valor sumale uno y guardalo dentro del mismo x.
Entonces, cuando yo lo llame la primera vez, lo que me va a ir mostrando es 1 2 3 y le va a ir sumando uno a esta variable que tengo acá, porque lo que le fue haciendo es primero le sumo uno, después le sumo dos, 2 + 1 me va a dar 3. Entonces, por cada vez que yo le estoy sumando, estoy usando la variable distancia que se llama x. Sí, vamos a ver esto.
Para ver este ejemplo, me voy a ir al Visual Studio y voy a abrir ese partil animal. ¿Sí? Entonces, fíjense, acá tengo la definición de la clase, le paso el nombre de la clase, genero el atributo de esa clase. Acá tengo un método que lo que le estoy diciendo es recibe por parámetro eh así mismo y le sumo uno y me imprime en pantalla hasta ahora y cada vez que lo llamo me va a devolver eso. Sí, voy a comentar estos dos.
para que veamos eh para que no se ejecuten. Sí. Y acá lo que hago es llamo a la clase, genero un objeto. A partir de ahora, ese objeto en la memoria se llama AN y del objeto AN uso el método Party y Party va a recibir su mismo objeto. Sí. Y me va a pasar ese cero. Entonces voy a voy a guardar esto y lo voy a ejecutar.
Y fíjense que acá dice hasta ahora uno. ¿Por qué? Porque lo llamé una sola vez. Entonces, a cer0 le sumo uno cuando imprimo x, imprimo de esa misma instancia y primo su valor x, me va a dar 1. En cambio, si ahora luego distanciarlo lo llamo tres veces, voy a salvarlo, voy a volver a ejecutarlo. Vamos a ver qué me dice.
Un, dos, 3, porque por cada vez que le voy haciendo se va guardando en la memoria ese objeto. ¿Sí? ¿Me van siguiendo hasta acá? Sí. Bien. Sí. Voy a volver a la presentación. Sí. Entonces, cuando nosotros queremos ver cuál es la funcionalidad que tiene un objeto, qué métodos, qué campos tiene, tenemos el comando DIR, que yo se los había mostrado.
¿Sí? Ignoremos por ahora todos estos que dicen guion bajo, guion bajo, que los vamos a ver más adelante, ¿sí? Pero el resto de las palabras que aparezcan, ¿sí? Son los métodos. Entonces, tanto DIR como Tight me dice qué es lo que tiene ese objeto. Si yo ahora me voy, por ejemplo, al código que teníamos acá arriba, eh, que teníamos en el visual, permítame envolver acá.
Aparte de hacer esto, lo voy a hacer acá. Ahora voy a hacer lo siguiente. Voy a hacer un print. ¿Y qué voy a imprimir? Voy a imprimir lo que me devuelva type. Pero el type de ¿qué? De AN, del objeto que acabo de crear. Sí, voy a ejecutar de vuelta esto. Y fíjense que me dice esto es de la clase party animal, que es la clase que yo definí. Sí.
Y dice Mine porque la clase está definida dentro del mismo del mismo archivo. Sí, pero acá me dice que es de la clase partil animal. Ahora, si yo aparte del print este le pongo un print eh dir a an, lo salvo, lo ejecuto de nuevo. Fíjense que me está diciendo todos los que tienen variables bajas, que le dije, bueno, vamos a dejarlo, vamos a dejarlo por ahora, pero me dice, tengo un party y tengo un X.
Quiere decir que yo puedo hacer referencia a el objeto punto party y también puedo hacer referencia al objeto punto X. ¿Sí? Entonces, puedo ver el valor y puedo llamar al método. Puedo ver un campo, un atributo o puedo usar la función. Sí, fíjense que me aparece acá. Entonces nosotros podemos usar dir y type objetos, para ver cómo están compuestos, para ver qué funcionalidades tienen.
¿Sí? Entonces acá está justamente el ejemplo que acabamos de hacer, el type y el DI de este objeto party, ¿sí?, que nosotros acabamos de generar, del parting animal. Ahora, esto del partil animal nosotros lo podemos eh usar para distintas cosas. Cuando nosotros estamos creando, instanciando un objeto, a partir de ese momento el objeto empieza a estar vivo en memoria.
¿Sí? Y como yo les decía, los objetos se crean y cuando ya no lo usamos más, se borran de la memoria. Por lo tanto, hay dos métodos que por ser objeto todos los objetos tienen. Dos métodos que son el constructor y el destructor. ¿Sí? Cada vez que nosotros instanciamos un objeto, estamos llamando al constructor y cada vez que nosotros terminamos la ejecución de ese programa se llama al destructor.
¿Para qué? para eliminarlo y limpiarlo de la memoria, porque si no todas esas variables quedarían todo el tiempo en la memoria. Sí, Python tiene ese recolector de memoria que lo que hace es cada vez que terminamos de ejecutar algo, todos los objetos que se crearon con el destructor se borran de esa memoria.
¿Sí? Entonces, los constructores lo vamos a usar mucho y son esas instancias que eh poníamos entre paréntesis el nombre de de la clase. Ese es el constructor y el destructor se usa solo y muy rara vez cuando necesitemos algo muy específico. ¿Sí? Entonces, ¿cuál es el propósito principal del constructor? Bueno, a veces necesitamos instanciar una clase, pero que tenga ciertas eh ciertos valores preestablecidos.
Yo quiero que se genere un objeto del tipo perro, pero que ya tenga una configuración. ¿Sí? Entonces, yo puedo armar y modificar ese constructor. Sí. Y también puedo armar ese destructor, tanto el constructor como el destructor. En Python se usa esto, guion guaj init y gu bajo delt. Este es el constructor y este es el destructor.
¿Sí? Cuando yo instancio el objeto se está llamando al constructor. Entonces, todo lo que está dentro del constructor se va a ejecutar. Cuando yo borro un objeto, lo que se vaya lo que se llama es al destructor. ¿Sí? Entonces, yo les dejé un party dos, que es lo que es para que podamos verlo en ejecución. Sí.
Si yo ejecuto ese parte dos, se los dejé ahí eh dentro de repositorio. Voy a cerrar este, este y esto. Y voy a abrir este parte dos. Sí, fíjense en acá está eh la función que vamos a usar y acá al constructor por defecto que existe no tiene código, pero yo lo que estoy haciendo es sobrescribiéndolo, le estoy agregando funcionalidad, le estoy diciendo que imprima, estoy construido, ¿sí? Y al destructor que es gu bajo del le estoy diciendo estoy destruido y que me imprima cuál es el valor de x. Sí. Como nosotros eh el destructor solo se
va a llamar al momento de cerrar el programa, voy a forzar a que se destruya el objeto. ¿Cómo lo voy a forzar? Cambiándole y pisándole el valor. ¿Sí? Entonces, acá le estoy diciendo an, estoy llamando al constructor party animal. Cuando yo pongo partir animal, le estoy llamando a esto. Entonces se llama, se crea la instancia y se va a llamar a este constructor.
Después uso partí uno dos veces y acá la variable la piso con un 42. Cuando la estoy pisando con un 42, lo estoy cambiando a esa clase, esa variable ya no es más del tipo party, ahora es del tipo entero, entonces la estoy destruyendo. En ese caso se va a llamar al destructor. Y después acá abajo lo que voy a hacer es cargar en memoria.
Sí, voy a a ver qué quedó en la memoria, qué contiene esa variable. Para poder seguir esto paso a paso, vamos a usar esto del debback que habíamos hecho la otra vez. Sí. Entonces, voy a pararme acá, voy a dejar eso ahí, lo voy a poner en ejecutar para que lo veamos una vez ejecutándose. C.
Y fíjense que dice, "Estoy construido hasta ahora uno, hasta ahora dos. Cuando se pisó dice estoy destruido." Y después al final, como lo pisé, me está diciendo ahora que el valor ya no es una clase, sino que es el 42. Sí. Si esto lo hacemos en modo de debag, es de que habíamos visto en algún momento que podíamos debaguear paso a paso. Vamos a venir acá, vamos a ejecutar en modo de bag para poder ir viéndolo.
Ahí se está llamando, se va a ir ejecutando y cuando llegue acá se va a pisar. Sí, ahí está. Ahí llegó. Ahí se paró. Si yo me fijo ahora, no tengo variables, no hay nada cargado, cuando ejecute esta línea, lo que va a hacer es llamar al constructor. Fíjense que se ejecutó el constructor. Sí. Entonces, acá dice estoy construido.
Y fíjense que me imprimió, estoy construido, se creó en memoria. Ahora sí. se ejecutó es estoy construido y si hago un pasito más, fíjense que ahora en memoria me va a parecer que tengo un objeto acá, tengo un an que es del tipo party animal y que adentro tiene todos los métodos y uno de ellos va a ser el party. A ver si puedo hacer lo que vaya más para abajo para que entre todo.
Vamos achicar un cachito de la letra. Ahí está. Sí. Acá tengo la variable que ahora está en cero. Sí. Y tengo el método party. Acá está. Tengo la variable en cero y el método en party. Lo ejecuto una vez. se va a ir a la función. Acá la llamé. Entonces va a la función, se suma.
Entonces ahora x, si yo me fijo acá, ahora x vale 1, por lo tanto imprime el valor de x. Acá me va a decir que vale uno. Hasta ahora uno. Listo, se ejecutó esta línea. En la segunda línea lo vuelvo a llamar, vuelve a ir a la función. Ahora ax que vale 1, sí le va a sumar uno más. Entonces ahora x vale 2. Por eso cuando ejecute la línea esta va a imprimir. Ahora vale dos.
Hago uno más y acá este objeto que es de la clase party animal, ahora lo voy a pisar y lo voy a destruir poniéndole otro valor, por lo tanto se va a llamar al destructor. Ahí que lo acabo de pisar, me va a decir que ahora está destruido y que an contiene dos. 42. Estoy destruido. Sí. y se destruyó con el valor de dos.
La última vez que este objeto en memoria funcionaba tenía un dos. ¿Sí? Entonces acá vemos el concepto distancia. Tengo una funcionalidad que viene dada por la función party, su constructor, su destructor. Tengo unos campos. Sí. Y acá lo que hice fue cada vez que aparecía un animal le sumaba uno. Sí, es es un ejemplo tonto, pero para que vean cómo funciona. Voy a volver a la presentación. Sí, eso fue lo que lo que ejecutamos recién.
Estoy destruido. Sí. Entonces, tanto el constructor como el como el destructor son opcionales. El constructor se va a utilizar normalmente cuando queramos configurar alguna variable, cuando queramos que se cree el objeto con algún valor puntual. Sí. Y el destructor lo van a usar muy rara vez cuando necesiten alguna funcionalidad muy específica.
Ahora, y con esto vamos a cerrar la clase de hoy. Puedo tener muchas instancias de un objeto de la misma clase. ¿Sí? Entonces, en la programación orientado a objetos, el constructor de una clase es ese bloque especial que lo vamos a llamar cada vez que yo cree un objeto.
Pero yo puedo crear muchos objetos de esa clase, ¿sí? Y cada objeto se va a almacenar en la memoria con su propio nombre de variable y vamos a poder llamar a cada objeto por esa variable. Y son todos de la misma clase, pero cada uno va a tener sus propios valores, como vimos los casos de los perros, ¿no? Y cada instancia va a tener su propia variable de distancia y cada instancia va a tener sus propios métodos.
Entonces, yo puedo crearme, acá vemos un código donde estoy generándome dos contadores, ¿sí? y le estoy poniendo x = 0 name, le estoy poniendo un vacío en el constructor. Lo que estoy haciendo acá es definir que el nombre sea igual al nombre de que le estoy pasando por parámetro. Entonces, le paso la instancia y la variable Z. Como acá le estoy pasando esa variable, eso es lo que le estoy pasando acá.
Entonces, acá le estoy pasando el nombre y se le va a asignar cuando se construye. Le va a asignar un nombre y va a decir se construyó tal. Y esto del contador va a decir, bueno, voy a usar de este objeto su nombre y voy a decir cuánto tiene la variable X. Recuento.
Y acá estoy generando dos instancias distintas, una que es la S y otra que es la J. Entonces, ¿qué hace este código? Voy a tener en los constructores y cada constructor sí va a instanciar uno con el nombre Omar, otro con el nombre Juan y cada uno va a tener su propia variable. Por lo tanto, si yo ahora ejecuto el Python instancias, vamos a ver qué dice esto.
Osmar construido, Juan construido, recuento uno, recuento uno, recuento dos. Sí. Entonces, vamos a ir al código para ver puntualmente este caso. ¿Sí? ¿Qué va a pasar cuando estoy acá? Estoy llamando al a la clase y le paso unos parámetros, en este caso un nombre. Entonces, ¿esto qué hace? me crea en memoria un S y ese S va a tener una x = 0, porque se lo estoy inicializando acá, y un nombre que en principio se crea vacío, pero cuando se construye eso que recibe, que lo tengo acá, se le asigna al campo name. Por eso el constructor lo que hace es instanciar
ese objeto ya inicializado. Esta segunda línea va a ser lo mismo, pero en este caso me va a generar un J que también va a tener, va a recibir el nombre Juan. Juan va a pasar por el constructor y se lo va a instanciar al campo name, por eso me aparece acá. Y el cero va a quedar en cero. Perfecto. Entonces, ahora tengo dos instancias distintas.
Acá acabo de instanciar dos objetos de la misma clase, pero cada uno tiene su nombre y cada uno tiene su X. Acá llamo al party, pero del primer objeto, por lo tanto, la primera vez me va a decir recuento uno. Entonces este valor va a valer uno. Acá estoy llamando al J, por eso acá me dice Juan recuento uno.
Estoy cambiando este valor a uno y acá vuelvo a llamar a a la instancia S, a la primera instancia y como ya tenía uno, por eso acá me va a decir dos. Sí, vamos. Les voy a mostrar esto en el código. Voy a cerrar este. Y esto lo tenemos acá en instancias. Sí. Voy a cerrar las terminales y lo voy a ejecutar una vez para que veamos.
Sí, es exactamente el mismo código que les mostré en la presentación, solo que ya lo tienen acá para que no tengan que estar escribiéndolo. ¿Sí? Entonces, le paso, le digo, "Toma tu instancia y al parámetro que estás recibiendo, guardalo el nombre." Entonces, si yo ahora lo ejecuto, ¿sí? Fíjense que cuando instancié la primera vez, cuando se ejecuta esta línea, me dice Omar construido. Cuando le ejecuté la segunda línea, me dice Juan construido.
Sí, lo voy a poner acá y lo vamos a hacer un debba. Y con esto vamos redondeando. Si hay alguna duda, alguna pregunta, la pueden ir haciendo. Sí, mientras puedo ahora eh si yo vuelvo a hacer eh por ejemplo con otra variable eh m igual a parte animal y entre paréntesis le envío eh Omar de nuevo con otra variable, ¿cómo la va a contemplar cuando se ponga? otro objeto distinto que tiene el mismo el mismo campo, ¿okay? Que justamente tiene el mismo valor, pero es un objeto distinto porque vos le estás poniendo un y y party lo va a tomar como uno, como otro otro vas a tener tres. Justo
coincide que se repita el nombre, pero no no no es que si es distinto, es igual porque tiene el mismo nombre, es un objeto distinto. ¿Por qué es distinto? Porque acá le estoy poniendo un m, le estoy instanciando en memoria otro objeto que coincide en los valores del nombre.
Se llaman igual, tienen el campo nombre, contienen el mismo valor, pero son objetos distintos. Sí, sí. Okay, entiendo. Bien, entonces en este caso vamos a ver justamente voy a ejecutar esta línea. Llama al constructor. En este caso, fíjense que Z está recibiendo el Omar. Se lo va a asignar. Entonces, fíjense que Z ahora vale Omar. Sí, ahí dice Omar construido. ¿Por qué? Porque ya usó el constructor.
Ahora cuando me vaya a construir el segundo, recibe Z, recibe Juan, se lo asigna al campo name y me va a decir Juan construido. Bien, ahora cuando yo esté llamando, llamo de manera intercalada, ¿no? Entonces va a haber uno que lo voy a llamar dos veces y uno que lo voy a llamar una. llamo al primero. Ese era Omar. Entonces me va a mostrar cuando llegue a esa parte. Sí, tengo las dos instancias.
¿Ves que están en memoria? Están en posiciones distintas. Entonces son instancias distintas. Si tengo un tercero y le paso Omar por nombre, van a ser tres instancias distintas, solo que hay dos que tienen en ese campo el mismo valor. Sí, lo que los hace diferente es que están en otro lugar de la memoria.
¿Sí? Entonces ahí me va a decir el primer recuento uno, Juan recuento dos y cuando llame de nuevo al al que tenía como nombre mar, como ahí adentro este ya tenía un uno, cuando le incremente uno más me va a decir dos. Sí, ahí le puso el dos. Entonces ahora cuando imprima me va a decir Omar 2. Termina y se va a llamar a todos los destructores, que yo ahora acá no lo tengo, pero se va a llamar a todos los destructores y se destruye. Sí, como no como no lo definí, no no estoy viendo nada, pero se llamó y se borraron todos
esos objetos de memoria. ¿Sí? Entonces cada una de estas variables son objetos distintos que los tengo en memoria. Sí. Y cada uno va a tener sus campos y cada uno va a tener sus funciones. Después vamos a ver cómo podemos utilizar esta idea del objeto para usar sistemas, para armar programas, pero quería que prueben y vean primero esto.
¿Sí? Entonces, usando el editor, les dejo como desafío, como tarea, que tomen este código, ¿sí?, que dice desafío uno y traten de transformar esto que es eh código eh secuencial donde definíamos una función, otra función y acá la usábamos. Traten de convertir esto a clases que tengan una clase triángulo, una clase rectángulo y que cada una tenga el método calcular área.
Sí, como tarea. Y después, desafío dos, este código tiene un error. Sí, traten de identificar cuál es ese error y de corregirlo. Sí, todo esto se los estoy dejando en el repositorio. Acá dentro tienen desafío uno. Sí, acá les dejo el código para que tomen como base.
Y lo que tienen que hacer es esto que es programación estructurada a programación orientada por objetos. Transformar este código en un conjunto de clases, triángulo y rectángulo. Cada una de esas clases tiene que tener el método de calcular el área. ¿Sí? Entonces, acá tienen la función, acá tienen algunas variables. Lo que quiero es que lo transformen a clases, ¿sí? Y que después puedan instanciar una un triángulo, que puedan instanciar un un cuadrado, un rectángulo, ¿sí? Y puedan hacer el uso de las de esas clases.
La clase que viene vamos a ustedes me van a a mostrar qué es lo que hicieron y si quieren compartirlo en la semana por WhatsApp lo pueden hacer. Sí. Y vamos a arrancar viendo esos ejemplos y cómo lo podríamos haber resuelto. Y el desafío dos, acá hay algunos errores, ¿sí? ¿Cómo es? A ver si se dan cuenta cuál es el problema y por qué está marcando esos errores.
¿Sí? Hasta acá la clase de hoy. La idea es tener esta pequeña introducción sobre objetos. Vamos a avanzar mucho más y a ponerlos en práctica a partir de la clase que viene. ¿Sí? ¿Dudas, preguntas? Por ahora no. Mañana cuando empecemos a hacer ejercicios veremos. Perfecto. Bueno, perdón que me haya extendido un poquito, pero no quería atrasarme mucho más y tampoco como son temas importantes, me parece que el tiempo de consulta también hay que hay que tenerlo. Así que les dejo esas dos tareas, traten de resolverlas y la clase
que viene vamos a retomar a partir de este punto, ¿sí? Así que bueno, fin de semana y nos vemos la la semana que viene. Sí, buen fin de semana. Apenas esté la grabación les aviso como siempre para que la tengan ahí disponible. la practiquen y tienen esos dos ejercicios, así que tienen tarea. Nos vemos la semana que viene.
Gracias que viene. Hasta luego. Gracias.